{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-scroller.js","webpack:///webpack/bootstrap 5b85c0c814aadc9802ba","webpack:///./src/main.js","webpack:///./~/node-libs-browser/~/process/browser.js","webpack:///./src/components/react-scroller.js","webpack:///./~/q/q.js","webpack:///./~/setimmediate/setImmediate.js","webpack:///./~/timers-browserify/main.js","webpack:///external \"classnames\"","webpack:///external \"next-browser\"","webpack:///external \"next-dom-event\"","webpack:///external \"next-scroller\"","webpack:///external \"noop\"","webpack:///external \"prop-types\"","webpack:///external \"react\"","webpack:///external \"react-event-emitter\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_6__","__WEBPACK_EXTERNAL_MODULE_7__","__WEBPACK_EXTERNAL_MODULE_8__","__WEBPACK_EXTERNAL_MODULE_9__","__WEBPACK_EXTERNAL_MODULE_10__","__WEBPACK_EXTERNAL_MODULE_11__","__WEBPACK_EXTERNAL_MODULE_12__","__WEBPACK_EXTERNAL_MODULE_13__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_reactScroller","_reactScroller2","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","e","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","length","queue","concat","queueIndex","drainQueue","timeout","len","run","Item","array","noop","process","nextTick","args","Array","arguments","i","push","prototype","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask","_objectWithoutProperties","keys","target","indexOf","hasOwnProperty","_defineProperty","key","enumerable","configurable","writable","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","undefined","_class","_temp","_extends","assign","source","_createClass","defineProperties","props","descriptor","protoProps","staticProps","_react","_react2","_nextBrowser","_nextBrowser2","_nextDomEvent","_nextDomEvent2","_propTypes","_propTypes2","_q","_reactEventEmitter","_reactEventEmitter2","_nextScroller","_nextScroller2","_classnames","_classnames2","_noop","_noop2","userAgent","navigator","helperElem","document","createElement","vendorPrefix","jsPrefix","perspectiveProperty","transformProperty","supportTransformProperty","style","supportPerspectiveProperty","retainElementRE","INNER_STATUS","deviceIsWindowsPhone","deviceIsIOS","test","_default","_ReactEventEmitter","_this","getPrototypeOf","_onStart","inEvent","shouldRetainDefault","preventDefault","_scroller","doTouchStart","touches","timeStamp","_onRefresh","refresh","_onMove","onScroll","scrollValues","getValues","doTouchMove","activateInfinite","fire","_onEnd","doEnd","delayCheck","doTouchEnd","init","_mouted","_props","refresherStatus","infiniterStatus","attachDocEvents","createScroller","activatePullToRrefresh","state","contentStyle","inNextProps","setState","nextProps","children","_loadRes","window","_touchmoveRes","_touchendRes","destory","options","scrollerRender","_refs","refs","container","content","setDimensions","clientWidth","clientHeight","offsetWidth","offsetHeight","inLeft","inTop","inAnimate","inZoom","scrollTo","_this2","left","top","transformPropertyValue","marginLeft","marginTop","_refs2","_props2","distances","infiniter","isInnerStatus","contentBound","getBoundingClientRect","containerBound","console","log","bottom","_this3","_props3","refresher","onRefresh","activatePullToRefresh","__refreshActive","finishPullToRefresh","tagName","match","_this4","_props4","onInfinite","onScrollEnd","_this5","timer","_props5","className","ref","onTouchStart","status","propTypes","string","object","func","distance","defaultProps","animationDuration","scrollingX","speedMultiplier","penetrationDeceleration","penetrationAcceleration","setImmediate","definition","bootstrap","uncurryThis","f","isObject","isStopIteration","exception","object_toString","QReturnValue","makeStackTraceLong","error","promise","hasStacks","stack","stacks","__minimumStackCounter__","stackCounter","object_defineProperty","unshift","concatedStacks","join","STACK_JUMP_SEPARATOR","filterStackString","stackString","lines","split","desiredLines","line","isInternalFrame","isNodeFrame","stackLine","getFileNameAndLineNumber","attempt1","exec","Number","attempt2","attempt3","fileNameAndLineNumber","fileName","lineNumber","qFileName","qStartingLine","qEndingLine","captureLine","firstLine","deprecate","callback","alternative","warn","Q","Promise","isPromiseAlike","coerce","fulfill","defer","become","newPromise","resolvedPromise","longStackSupport","array_reduce","messages","message","promiseDispatch","progressListeners","deferred","object_create","resolve","op","operands","array_slice","valueOf","nearerValue","nearer","isPromise","inspect","substring","longStackCounter","reject","reason","notify","progress","progressListener","resolver","race","answerPs","then","fallback","result","inspected","when","fulfilled","rejected","progressed","isPending","isFulfilled","isRejected","resetUnhandledRejections","unhandledReasons","unhandledRejections","trackUnhandledRejections","trackRejection","runAfter","array_indexOf","reportedUnhandledRejections","untrackRejection","at","atReport","splice","rejection","get","set","rhs","delete","post","thisp","object_keys","master","isDef","dispatch","spread","async","makeGenerator","continuer","verb","arg","StopIteration","generator","done","errback","bind","spawn","_return","promised","all","promises","pendingCount","index","snapshot","any","prev","current","onFulfilled","onRejected","err","onProgress","allResolved","array_map","allSettled","nodeify","nodeback","flush","task","domain","head","next","enter","runSingle","laterQueue","pop","flushing","isNodeJS","exit","tail","requestTick","toString","MessageChannel","channel","port1","onmessage","requestPortTick","port2","postMessage","Function","slice","reduce","basis","map","collect","Type","prop","object_hasOwnProperty","ReturnValue","NODE_ENV","Q_DEBUG","makeNodeResolver","passByCopy","x","y","that","makePromise","_fulfilled","_rejected","newException","_progressed","newValue","threw","onerror","tap","fcall","thenResolve","thenReject","getUnhandledReasons","stopUnhandledRejectionTracking","del","mapply","send","mcall","invoke","fapply","fbind","regardless","fail","fin","onUnhandledError","ms","timeoutId","code","delay","nfapply","nodeArgs","nfcall","nfbind","denodeify","baseArgs","nbind","bound","nmapply","npost","nsend","nmcall","ninvoke","noConflict","global","tasksByHandle","nextHandle","registerImmediate","clearImmediate","handle","runIfPresent","currentlyRunningATask","installNextTickImplementation","canUsePostMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","installPostMessageImplementation","messagePrefix","Math","random","onGlobalMessage","event","data","addEventListener","attachEvent","installMessageChannelImplementation","installReadyStateChangeImplementation","html","doc","documentElement","script","onreadystatechange","removeChild","appendChild","installSetTimeoutImplementation","attachTo","Timeout","clearFn","_id","_clearFn","setInterval","clearInterval","close","unref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout"],"mappings":"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","file":"react-scroller.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"classnames\"), require(\"next-browser\"), require(\"next-dom-event\"), require(\"next-scroller\"), require(\"noop\"), require(\"prop-types\"), require(\"react\"), require(\"react-event-emitter\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"classnames\", \"next-browser\", \"next-dom-event\", \"next-scroller\", \"noop\", \"prop-types\", \"react\", \"react-event-emitter\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactScroller\"] = factory(require(\"classnames\"), require(\"next-browser\"), require(\"next-dom-event\"), require(\"next-scroller\"), require(\"noop\"), require(\"prop-types\"), require(\"react\"), require(\"react-event-emitter\"));\n\telse\n\t\troot[\"ReactScroller\"] = factory(root[\"classnames\"], root[\"next-browser\"], root[\"next-dom-event\"], root[\"next-scroller\"], root[\"noop\"], root[\"prop-types\"], root[\"react\"], root[\"react-event-emitter\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_9__, __WEBPACK_EXTERNAL_MODULE_10__, __WEBPACK_EXTERNAL_MODULE_11__, __WEBPACK_EXTERNAL_MODULE_12__, __WEBPACK_EXTERNAL_MODULE_13__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"classnames\"), require(\"next-browser\"), require(\"next-dom-event\"), require(\"next-scroller\"), require(\"noop\"), require(\"prop-types\"), require(\"react\"), require(\"react-event-emitter\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"classnames\", \"next-browser\", \"next-dom-event\", \"next-scroller\", \"noop\", \"prop-types\", \"react\", \"react-event-emitter\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactScroller\"] = factory(require(\"classnames\"), require(\"next-browser\"), require(\"next-dom-event\"), require(\"next-scroller\"), require(\"noop\"), require(\"prop-types\"), require(\"react\"), require(\"react-event-emitter\"));\n\telse\n\t\troot[\"ReactScroller\"] = factory(root[\"classnames\"], root[\"next-browser\"], root[\"next-dom-event\"], root[\"next-scroller\"], root[\"noop\"], root[\"prop-types\"], root[\"react\"], root[\"react-event-emitter\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_9__, __WEBPACK_EXTERNAL_MODULE_10__, __WEBPACK_EXTERNAL_MODULE_11__, __WEBPACK_EXTERNAL_MODULE_12__, __WEBPACK_EXTERNAL_MODULE_13__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _reactScroller = __webpack_require__(2);\n\t\n\tvar _reactScroller2 = _interopRequireDefault(_reactScroller);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = _reactScroller2.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = undefined;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _class, _temp;\n\t\n\tvar _react = __webpack_require__(12);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _nextBrowser = __webpack_require__(7);\n\t\n\tvar _nextBrowser2 = _interopRequireDefault(_nextBrowser);\n\t\n\tvar _nextDomEvent = __webpack_require__(8);\n\t\n\tvar _nextDomEvent2 = _interopRequireDefault(_nextDomEvent);\n\t\n\tvar _propTypes = __webpack_require__(11);\n\t\n\tvar _propTypes2 = _interopRequireDefault(_propTypes);\n\t\n\tvar _q = __webpack_require__(3);\n\t\n\tvar _q2 = _interopRequireDefault(_q);\n\t\n\tvar _reactEventEmitter = __webpack_require__(13);\n\t\n\tvar _reactEventEmitter2 = _interopRequireDefault(_reactEventEmitter);\n\t\n\tvar _nextScroller = __webpack_require__(9);\n\t\n\tvar _nextScroller2 = _interopRequireDefault(_nextScroller);\n\t\n\tvar _classnames = __webpack_require__(6);\n\t\n\tvar _classnames2 = _interopRequireDefault(_classnames);\n\t\n\tvar _noop = __webpack_require__(10);\n\t\n\tvar _noop2 = _interopRequireDefault(_noop);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar userAgent = navigator.userAgent;\n\tvar helperElem = document.createElement(\"div\");\n\tvar vendorPrefix = _nextBrowser2.default.jsPrefix();\n\tvar perspectiveProperty = vendorPrefix + \"Perspective\";\n\tvar transformProperty = vendorPrefix + \"Transform\";\n\tvar supportTransformProperty = helperElem.style[transformProperty] !== undefined;\n\tvar supportPerspectiveProperty = helperElem.style[perspectiveProperty] !== undefined;\n\tvar retainElementRE = /input|textarea|select/i;\n\tvar INNER_STATUS = ['init', 'active', 'running'];\n\t\n\t//devices judgements:\n\tvar deviceIsWindowsPhone = userAgent.indexOf(\"Windows Phone\") >= 0;\n\tvar deviceIsAndroid = userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;\n\tvar deviceIsIOS = /iP(ad|hone|od)/.test(userAgent) && !deviceIsWindowsPhone;\n\t\n\tvar _default = (_temp = _class = function (_ReactEventEmitter) {\n\t  _inherits(_default, _ReactEventEmitter);\n\t\n\t  function _default(props) {\n\t    _classCallCheck(this, _default);\n\t\n\t    var _this = _possibleConstructorReturn(this, (_default.__proto__ || Object.getPrototypeOf(_default)).call(this, props));\n\t\n\t    _this._onStart = function (inEvent) {\n\t      if (!_this.shouldRetainDefault(inEvent) && deviceIsIOS) {\n\t        inEvent.preventDefault();\n\t      }\n\t      _this._scroller.doTouchStart(inEvent.touches, inEvent.timeStamp);\n\t    };\n\t\n\t    _this._onRefresh = function () {\n\t      _this.refresh();\n\t    };\n\t\n\t    _this._onMove = function (inEvent) {\n\t      var onScroll = _this.props.onScroll;\n\t\n\t      var scrollValues = _this._scroller.getValues();\n\t      if (_this.shouldRetainDefault(inEvent)) {\n\t        return null;\n\t      }\n\t      _this._scroller.doTouchMove(inEvent.touches, inEvent.timeStamp);\n\t      _this.activateInfinite();\n\t      onScroll(scrollValues);\n\t      _this.fire('scroll', scrollValues);\n\t      inEvent.preventDefault();\n\t    };\n\t\n\t    _this._onEnd = function (inEvent) {\n\t      _this.doEnd(inEvent);\n\t      _this.delayCheck();\n\t      _this._scroller.doTouchEnd(inEvent.timeStamp);\n\t    };\n\t\n\t    _this.init();\n\t    _this._mouted = false;\n\t    return _this;\n\t  }\n\t\n\t  _createClass(_default, [{\n\t    key: 'init',\n\t    value: function init() {\n\t      var _props = this.props,\n\t          refresherStatus = _props.refresherStatus,\n\t          infiniterStatus = _props.infiniterStatus;\n\t\n\t      this.attachDocEvents();\n\t      this.createScroller();\n\t      this.activatePullToRrefresh();\n\t      this.state = {\n\t        contentStyle: {},\n\t        refresherStatus: refresherStatus,\n\t        infiniterStatus: infiniterStatus\n\t      };\n\t    }\n\t  }, {\n\t    key: 'componentAttachEvents',\n\t    value: function componentAttachEvents() {}\n\t  }, {\n\t    key: 'componentWillUnmount',\n\t    value: function componentWillUnmount() {\n\t      // this.detachDocEvents();\n\t      // this._scroller = null;\n\t      this._mouted = false;\n\t      // super.componentWillUnmount();\n\t    }\n\t  }, {\n\t    key: 'componentDidMount',\n\t    value: function componentDidMount() {\n\t      this.refresh();\n\t      this._mouted = true;\n\t    }\n\t  }, {\n\t    key: 'componentWillReceiveProps',\n\t    value: function componentWillReceiveProps(inNextProps) {\n\t      this.setState(inNextProps);\n\t    }\n\t  }, {\n\t    key: 'componentDidUpdate',\n\t    value: function componentDidUpdate(nextProps) {\n\t      if (nextProps.children !== this.props.children) {\n\t        this.refresh();\n\t      }\n\t    }\n\t  }, {\n\t    key: 'attachDocEvents',\n\t    value: function attachDocEvents() {\n\t      this._loadRes = _nextDomEvent2.default.on(window, 'load', this._onRefresh);\n\t      this._touchmoveRes = _nextDomEvent2.default.on(document, 'touchmove', this._onMove);\n\t      this._touchendRes = _nextDomEvent2.default.on(document, 'touchend', this._onEnd);\n\t    }\n\t  }, {\n\t    key: 'detachDocEvents',\n\t    value: function detachDocEvents() {\n\t      this._loadRes.destory();\n\t      this._touchmoveRes.destory();\n\t      this._touchendRes.destory();\n\t    }\n\t  }, {\n\t    key: 'createScroller',\n\t    value: function createScroller() {\n\t      var options = this.props.options;\n\t\n\t      this._scroller = new _nextScroller2.default(this.scrollerRender(), options);\n\t    }\n\t  }, {\n\t    key: 'refresh',\n\t    value: function refresh() {\n\t      var _refs = this.refs,\n\t          container = _refs.container,\n\t          content = _refs.content;\n\t\n\t      this._scroller.setDimensions(container.clientWidth, container.clientHeight, content.offsetWidth, content.offsetHeight);\n\t    }\n\t  }, {\n\t    key: 'getValues',\n\t    value: function getValues() {\n\t      return this._scroller.getValues();\n\t    }\n\t  }, {\n\t    key: 'scrollTo',\n\t    value: function scrollTo(inLeft, inTop, inAnimate, inZoom) {\n\t      this._scroller.scrollTo(inLeft, inTop, inAnimate, inZoom);\n\t    }\n\t  }, {\n\t    key: 'scrollerRender',\n\t    value: function scrollerRender() {\n\t      var _this2 = this;\n\t\n\t      switch (true) {\n\t        case supportPerspectiveProperty:\n\t          return function (left, top, inZoom) {\n\t            var transformPropertyValue = 'translate3d(' + -left + 'px,' + -top + 'px,0) scale(' + inZoom + ')';\n\t            _this2._mouted && _this2.setState({ contentStyle: _defineProperty({}, transformProperty, transformPropertyValue) });\n\t          };\n\t        case supportTransformProperty:\n\t          return function (left, top, inZoom) {\n\t            var transformPropertyValue = 'translate(' + -left + 'px,' + -top + 'px) scale(' + inZoom + ')';\n\t            _this2._mouted && _this2.setState({ contentStyle: _defineProperty({}, transformProperty, transformPropertyValue) });\n\t          };\n\t        default:\n\t          return function (left, top, inZoom) {\n\t            var marginLeft = left ? -left / inZoom + 'px' : '';\n\t            var marginTop = top ? -top / inZoom + 'px' : '';\n\t            var zoom = inZoom || '';\n\t            _this2._mouted && _this2.setState({ contentStyle: { marginLeft: marginLeft, marginTop: marginTop, inZoom: inZoom } });\n\t          };\n\t      }\n\t    }\n\t  }, {\n\t    key: 'activateInfinite',\n\t    value: function activateInfinite() {\n\t      var _refs2 = this.refs,\n\t          container = _refs2.container,\n\t          content = _refs2.content;\n\t      var _props2 = this.props,\n\t          distances = _props2.distances,\n\t          infiniter = _props2.infiniter;\n\t\n\t      var isInnerStatus = INNER_STATUS.indexOf(this.state.infiniterStatus) > -1;\n\t      if (infiniter && isInnerStatus && container && content) {\n\t        var contentBound = content.getBoundingClientRect();\n\t        var containerBound = container.getBoundingClientRect();\n\t        console.log(contentBound.bottom - containerBound.bottom);\n\t        if (contentBound.bottom - containerBound.bottom < distances[1]) {\n\t          this.setState({ infiniterStatus: 'active' });\n\t        } else {\n\t          this.setState({ infiniterStatus: 'init' });\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: 'activatePullToRrefresh',\n\t    value: function activatePullToRrefresh() {\n\t      var _this3 = this;\n\t\n\t      var _props3 = this.props,\n\t          distances = _props3.distances,\n\t          refresher = _props3.refresher,\n\t          onRefresh = _props3.onRefresh;\n\t\n\t      if (refresher) {\n\t        this._scroller.activatePullToRefresh(distances[0], function () {\n\t          _this3.setState({ refresherStatus: 'active' });\n\t        }, function () {\n\t          _this3.setState({\n\t            refresherStatus: 'init',\n\t            infiniterStatus: 'init'\n\t          });\n\t        }, function () {\n\t          _this3.setState({ refresherStatus: 'running' });\n\t          _this3._scroller.__refreshActive && onRefresh.call(_this3, _this3);\n\t        });\n\t      }\n\t    }\n\t  }, {\n\t    key: 'finishInfinte',\n\t    value: function finishInfinte() {\n\t      var isInnerStatus = INNER_STATUS.indexOf(this.state.infiniterStatus) > -1;\n\t      if (isInnerStatus) {\n\t        this.setState({ infiniterStatus: 'init' });\n\t      }\n\t    }\n\t  }, {\n\t    key: 'finishPullToRefresh',\n\t    value: function finishPullToRefresh() {\n\t      this._scroller && this._scroller.finishPullToRefresh();\n\t    }\n\t  }, {\n\t    key: 'shouldRetainDefault',\n\t    value: function shouldRetainDefault(inEvent) {\n\t      return inEvent.target.tagName.match(retainElementRE);\n\t    }\n\t  }, {\n\t    key: 'doEnd',\n\t    value: function doEnd(inEvent) {\n\t      var _this4 = this;\n\t\n\t      var infiniterStatus = this.state.infiniterStatus;\n\t      var _props4 = this.props,\n\t          onInfinite = _props4.onInfinite,\n\t          onScrollEnd = _props4.onScrollEnd;\n\t\n\t      if (infiniterStatus === 'active') {\n\t        this.setState({ infiniterStatus: 'running' }, function () {\n\t          !_this4._scroller.__refreshActive && onInfinite.call(_this4, _this4);\n\t        });\n\t      }\n\t      onScrollEnd(inEvent);\n\t      this.fire('scrollEnd', inEvent);\n\t    }\n\t  }, {\n\t    key: 'delayCheck',\n\t    value: function delayCheck(inEvent) {\n\t      var _this5 = this;\n\t\n\t      var timer = setTimeout(function () {\n\t        _this5.activateInfinite();\n\t        _this5.doEnd(inEvent);\n\t        clearTimeout(timer);\n\t      }, 500);\n\t    }\n\t  }, {\n\t    key: 'render',\n\t    value: function render() {\n\t      var contentStyle = this.state.contentStyle;\n\t\n\t      var _props5 = this.props,\n\t          className = _props5.className,\n\t          children = _props5.children,\n\t          refresher = _props5.refresher,\n\t          infiniter = _props5.infiniter,\n\t          onInfinite = _props5.onInfinite,\n\t          onRefresh = _props5.onRefresh,\n\t          options = _props5.options,\n\t          distances = _props5.distances,\n\t          refresherStatus = _props5.refresherStatus,\n\t          infiniterStatus = _props5.infiniterStatus,\n\t          onScroll = _props5.onScroll,\n\t          onScrollEnd = _props5.onScrollEnd,\n\t          props = _objectWithoutProperties(_props5, ['className', 'children', 'refresher', 'infiniter', 'onInfinite', 'onRefresh', 'options', 'distances', 'refresherStatus', 'infiniterStatus', 'onScroll', 'onScrollEnd']);\n\t\n\t      return _react2.default.createElement(\n\t        'div',\n\t        _extends({}, props, {\n\t          ref: 'container',\n\t          className: (0, _classnames2.default)('react-scroller', className),\n\t          onTouchStart: this._onStart }),\n\t        _react2.default.createElement(\n\t          'div',\n\t          {\n\t            ref: 'content',\n\t            className: 'react-scroller-content', style: contentStyle },\n\t          refresher && (0, _react.createElement)(refresher, { status: this.state.refresherStatus }),\n\t          _react2.default.createElement(\n\t            'div',\n\t            { className: 'bd' },\n\t            children\n\t          ),\n\t          infiniter && (0, _react.createElement)(infiniter, { status: this.state.infiniterStatus })\n\t        )\n\t      );\n\t    }\n\t  }]);\n\t\n\t  return _default;\n\t}(_reactEventEmitter2.default), _class.propTypes = {\n\t  className: _propTypes2.default.string,\n\t  options: _propTypes2.default.object,\n\t  refresherStatus: _propTypes2.default.string,\n\t  infiniterStatus: _propTypes2.default.string,\n\t  onRefresh: _propTypes2.default.func,\n\t  refresher: _propTypes2.default.func,\n\t  infiniter: _propTypes2.default.func,\n\t  distance: _propTypes2.default.array,\n\t  onInfinite: _propTypes2.default.func,\n\t  onScroll: _propTypes2.default.func,\n\t  onScrollEnd: _propTypes2.default.func\n\t}, _class.defaultProps = {\n\t  options: {\n\t    animationDuration: 300,\n\t    scrollingX: false,\n\t    speedMultiplier: 0.8,\n\t    penetrationDeceleration: 0.1,\n\t    penetrationAcceleration: 0.1\n\t  },\n\t  refresherStatus: 'init',\n\t  infiniterStatus: 'init',\n\t  onRefresh: _noop2.default,\n\t  onInfinite: _noop2.default,\n\t  onScroll: _noop2.default,\n\t  onScrollEnd: _noop2.default,\n\t  refresher: null,\n\t  infiniter: null,\n\t  distances: [50, 50]\n\t}, _temp);\n\t\n\texports.default = _default;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// vim:ts=4:sts=4:sw=4:\n\t/*!\n\t *\n\t * Copyright 2009-2017 Kris Kowal under the terms of the MIT\n\t * license found at https://github.com/kriskowal/q/blob/v1/LICENSE\n\t *\n\t * With parts by Tyler Close\n\t * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n\t * at http://www.opensource.org/licenses/mit-license.html\n\t * Forked at ref_send.js version: 2009-05-11\n\t *\n\t * With parts by Mark Miller\n\t * Copyright (C) 2011 Google Inc.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t *\n\t */\n\t\n\t(function (definition) {\n\t    \"use strict\";\n\t\n\t    // This file will function properly as a <script> tag, or a module\n\t    // using CommonJS and NodeJS or RequireJS module formats.  In\n\t    // Common/Node/RequireJS, the module exports the Q API and when\n\t    // executed as a simple <script>, it creates a Q global instead.\n\t\n\t    // Montage Require\n\t    if (typeof bootstrap === \"function\") {\n\t        bootstrap(\"promise\", definition);\n\t\n\t    // CommonJS\n\t    } else if (true) {\n\t        module.exports = definition();\n\t\n\t    // RequireJS\n\t    } else if (typeof define === \"function\" && define.amd) {\n\t        define(definition);\n\t\n\t    // SES (Secure EcmaScript)\n\t    } else if (typeof ses !== \"undefined\") {\n\t        if (!ses.ok()) {\n\t            return;\n\t        } else {\n\t            ses.makeQ = definition;\n\t        }\n\t\n\t    // <script>\n\t    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n\t        // Prefer window over self for add-on scripts. Use self for\n\t        // non-windowed contexts.\n\t        var global = typeof window !== \"undefined\" ? window : self;\n\t\n\t        // Get the `window` object, save the previous Q global\n\t        // and initialize Q as a global.\n\t        var previousQ = global.Q;\n\t        global.Q = definition();\n\t\n\t        // Add a noConflict function so Q can be removed from the\n\t        // global namespace.\n\t        global.Q.noConflict = function () {\n\t            global.Q = previousQ;\n\t            return this;\n\t        };\n\t\n\t    } else {\n\t        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n\t    }\n\t\n\t})(function () {\n\t\"use strict\";\n\t\n\tvar hasStacks = false;\n\ttry {\n\t    throw new Error();\n\t} catch (e) {\n\t    hasStacks = !!e.stack;\n\t}\n\t\n\t// All code after this point will be filtered from stack traces reported\n\t// by Q.\n\tvar qStartingLine = captureLine();\n\tvar qFileName;\n\t\n\t// shims\n\t\n\t// used for fallback in \"allResolved\"\n\tvar noop = function () {};\n\t\n\t// Use the fastest possible means to execute a task in a future turn\n\t// of the event loop.\n\tvar nextTick =(function () {\n\t    // linked list of tasks (single, with head node)\n\t    var head = {task: void 0, next: null};\n\t    var tail = head;\n\t    var flushing = false;\n\t    var requestTick = void 0;\n\t    var isNodeJS = false;\n\t    // queue for late tasks, used by unhandled rejection tracking\n\t    var laterQueue = [];\n\t\n\t    function flush() {\n\t        /* jshint loopfunc: true */\n\t        var task, domain;\n\t\n\t        while (head.next) {\n\t            head = head.next;\n\t            task = head.task;\n\t            head.task = void 0;\n\t            domain = head.domain;\n\t\n\t            if (domain) {\n\t                head.domain = void 0;\n\t                domain.enter();\n\t            }\n\t            runSingle(task, domain);\n\t\n\t        }\n\t        while (laterQueue.length) {\n\t            task = laterQueue.pop();\n\t            runSingle(task);\n\t        }\n\t        flushing = false;\n\t    }\n\t    // runs a single function in the async queue\n\t    function runSingle(task, domain) {\n\t        try {\n\t            task();\n\t\n\t        } catch (e) {\n\t            if (isNodeJS) {\n\t                // In node, uncaught exceptions are considered fatal errors.\n\t                // Re-throw them synchronously to interrupt flushing!\n\t\n\t                // Ensure continuation if the uncaught exception is suppressed\n\t                // listening \"uncaughtException\" events (as domains does).\n\t                // Continue in next event to avoid tick recursion.\n\t                if (domain) {\n\t                    domain.exit();\n\t                }\n\t                setTimeout(flush, 0);\n\t                if (domain) {\n\t                    domain.enter();\n\t                }\n\t\n\t                throw e;\n\t\n\t            } else {\n\t                // In browsers, uncaught exceptions are not fatal.\n\t                // Re-throw them asynchronously to avoid slow-downs.\n\t                setTimeout(function () {\n\t                    throw e;\n\t                }, 0);\n\t            }\n\t        }\n\t\n\t        if (domain) {\n\t            domain.exit();\n\t        }\n\t    }\n\t\n\t    nextTick = function (task) {\n\t        tail = tail.next = {\n\t            task: task,\n\t            domain: isNodeJS && process.domain,\n\t            next: null\n\t        };\n\t\n\t        if (!flushing) {\n\t            flushing = true;\n\t            requestTick();\n\t        }\n\t    };\n\t\n\t    if (typeof process === \"object\" &&\n\t        process.toString() === \"[object process]\" && process.nextTick) {\n\t        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n\t        // To see through fake Node environments:\n\t        // * Mocha test runner - exposes a `process` global without a `nextTick`\n\t        // * Browserify - exposes a `process.nexTick` function that uses\n\t        //   `setTimeout`. In this case `setImmediate` is preferred because\n\t        //    it is faster. Browserify's `process.toString()` yields\n\t        //   \"[object Object]\", while in a real Node environment\n\t        //   `process.toString()` yields \"[object process]\".\n\t        isNodeJS = true;\n\t\n\t        requestTick = function () {\n\t            process.nextTick(flush);\n\t        };\n\t\n\t    } else if (typeof setImmediate === \"function\") {\n\t        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n\t        if (typeof window !== \"undefined\") {\n\t            requestTick = setImmediate.bind(window, flush);\n\t        } else {\n\t            requestTick = function () {\n\t                setImmediate(flush);\n\t            };\n\t        }\n\t\n\t    } else if (typeof MessageChannel !== \"undefined\") {\n\t        // modern browsers\n\t        // http://www.nonblocking.io/2011/06/windownexttick.html\n\t        var channel = new MessageChannel();\n\t        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n\t        // working message ports the first time a page loads.\n\t        channel.port1.onmessage = function () {\n\t            requestTick = requestPortTick;\n\t            channel.port1.onmessage = flush;\n\t            flush();\n\t        };\n\t        var requestPortTick = function () {\n\t            // Opera requires us to provide a message payload, regardless of\n\t            // whether we use it.\n\t            channel.port2.postMessage(0);\n\t        };\n\t        requestTick = function () {\n\t            setTimeout(flush, 0);\n\t            requestPortTick();\n\t        };\n\t\n\t    } else {\n\t        // old browsers\n\t        requestTick = function () {\n\t            setTimeout(flush, 0);\n\t        };\n\t    }\n\t    // runs a task after all other tasks have been run\n\t    // this is useful for unhandled rejection tracking that needs to happen\n\t    // after all `then`d tasks have been run.\n\t    nextTick.runAfter = function (task) {\n\t        laterQueue.push(task);\n\t        if (!flushing) {\n\t            flushing = true;\n\t            requestTick();\n\t        }\n\t    };\n\t    return nextTick;\n\t})();\n\t\n\t// Attempt to make generics safe in the face of downstream\n\t// modifications.\n\t// There is no situation where this is necessary.\n\t// If you need a security guarantee, these primordials need to be\n\t// deeply frozen anyway, and if you don’t need a security guarantee,\n\t// this is just plain paranoid.\n\t// However, this **might** have the nice side-effect of reducing the size of\n\t// the minified code by reducing x.call() to merely x()\n\t// See Mark Miller’s explanation of what this does.\n\t// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n\tvar call = Function.call;\n\tfunction uncurryThis(f) {\n\t    return function () {\n\t        return call.apply(f, arguments);\n\t    };\n\t}\n\t// This is equivalent, but slower:\n\t// uncurryThis = Function_bind.bind(Function_bind.call);\n\t// http://jsperf.com/uncurrythis\n\t\n\tvar array_slice = uncurryThis(Array.prototype.slice);\n\t\n\tvar array_reduce = uncurryThis(\n\t    Array.prototype.reduce || function (callback, basis) {\n\t        var index = 0,\n\t            length = this.length;\n\t        // concerning the initial value, if one is not provided\n\t        if (arguments.length === 1) {\n\t            // seek to the first value in the array, accounting\n\t            // for the possibility that is is a sparse array\n\t            do {\n\t                if (index in this) {\n\t                    basis = this[index++];\n\t                    break;\n\t                }\n\t                if (++index >= length) {\n\t                    throw new TypeError();\n\t                }\n\t            } while (1);\n\t        }\n\t        // reduce\n\t        for (; index < length; index++) {\n\t            // account for the possibility that the array is sparse\n\t            if (index in this) {\n\t                basis = callback(basis, this[index], index);\n\t            }\n\t        }\n\t        return basis;\n\t    }\n\t);\n\t\n\tvar array_indexOf = uncurryThis(\n\t    Array.prototype.indexOf || function (value) {\n\t        // not a very good shim, but good enough for our one use of it\n\t        for (var i = 0; i < this.length; i++) {\n\t            if (this[i] === value) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t);\n\t\n\tvar array_map = uncurryThis(\n\t    Array.prototype.map || function (callback, thisp) {\n\t        var self = this;\n\t        var collect = [];\n\t        array_reduce(self, function (undefined, value, index) {\n\t            collect.push(callback.call(thisp, value, index, self));\n\t        }, void 0);\n\t        return collect;\n\t    }\n\t);\n\t\n\tvar object_create = Object.create || function (prototype) {\n\t    function Type() { }\n\t    Type.prototype = prototype;\n\t    return new Type();\n\t};\n\t\n\tvar object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {\n\t    obj[prop] = descriptor.value;\n\t    return obj;\n\t};\n\t\n\tvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\t\n\tvar object_keys = Object.keys || function (object) {\n\t    var keys = [];\n\t    for (var key in object) {\n\t        if (object_hasOwnProperty(object, key)) {\n\t            keys.push(key);\n\t        }\n\t    }\n\t    return keys;\n\t};\n\t\n\tvar object_toString = uncurryThis(Object.prototype.toString);\n\t\n\tfunction isObject(value) {\n\t    return value === Object(value);\n\t}\n\t\n\t// generator related shims\n\t\n\t// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\n\tfunction isStopIteration(exception) {\n\t    return (\n\t        object_toString(exception) === \"[object StopIteration]\" ||\n\t        exception instanceof QReturnValue\n\t    );\n\t}\n\t\n\t// FIXME: Remove this helper and Q.return once ES6 generators are in\n\t// SpiderMonkey.\n\tvar QReturnValue;\n\tif (typeof ReturnValue !== \"undefined\") {\n\t    QReturnValue = ReturnValue;\n\t} else {\n\t    QReturnValue = function (value) {\n\t        this.value = value;\n\t    };\n\t}\n\t\n\t// long stack traces\n\t\n\tvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\t\n\tfunction makeStackTraceLong(error, promise) {\n\t    // If possible, transform the error stack trace by removing Node and Q\n\t    // cruft, then concatenating with the stack trace of `promise`. See #57.\n\t    if (hasStacks &&\n\t        promise.stack &&\n\t        typeof error === \"object\" &&\n\t        error !== null &&\n\t        error.stack\n\t    ) {\n\t        var stacks = [];\n\t        for (var p = promise; !!p; p = p.source) {\n\t            if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {\n\t                object_defineProperty(error, \"__minimumStackCounter__\", {value: p.stackCounter, configurable: true});\n\t                stacks.unshift(p.stack);\n\t            }\n\t        }\n\t        stacks.unshift(error.stack);\n\t\n\t        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n\t        var stack = filterStackString(concatedStacks);\n\t        object_defineProperty(error, \"stack\", {value: stack, configurable: true});\n\t    }\n\t}\n\t\n\tfunction filterStackString(stackString) {\n\t    var lines = stackString.split(\"\\n\");\n\t    var desiredLines = [];\n\t    for (var i = 0; i < lines.length; ++i) {\n\t        var line = lines[i];\n\t\n\t        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n\t            desiredLines.push(line);\n\t        }\n\t    }\n\t    return desiredLines.join(\"\\n\");\n\t}\n\t\n\tfunction isNodeFrame(stackLine) {\n\t    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n\t           stackLine.indexOf(\"(node.js:\") !== -1;\n\t}\n\t\n\tfunction getFileNameAndLineNumber(stackLine) {\n\t    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n\t    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n\t    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n\t    if (attempt1) {\n\t        return [attempt1[1], Number(attempt1[2])];\n\t    }\n\t\n\t    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n\t    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n\t    if (attempt2) {\n\t        return [attempt2[1], Number(attempt2[2])];\n\t    }\n\t\n\t    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n\t    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n\t    if (attempt3) {\n\t        return [attempt3[1], Number(attempt3[2])];\n\t    }\n\t}\n\t\n\tfunction isInternalFrame(stackLine) {\n\t    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\t\n\t    if (!fileNameAndLineNumber) {\n\t        return false;\n\t    }\n\t\n\t    var fileName = fileNameAndLineNumber[0];\n\t    var lineNumber = fileNameAndLineNumber[1];\n\t\n\t    return fileName === qFileName &&\n\t        lineNumber >= qStartingLine &&\n\t        lineNumber <= qEndingLine;\n\t}\n\t\n\t// discover own file name and line number range for filtering stack\n\t// traces\n\tfunction captureLine() {\n\t    if (!hasStacks) {\n\t        return;\n\t    }\n\t\n\t    try {\n\t        throw new Error();\n\t    } catch (e) {\n\t        var lines = e.stack.split(\"\\n\");\n\t        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n\t        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n\t        if (!fileNameAndLineNumber) {\n\t            return;\n\t        }\n\t\n\t        qFileName = fileNameAndLineNumber[0];\n\t        return fileNameAndLineNumber[1];\n\t    }\n\t}\n\t\n\tfunction deprecate(callback, name, alternative) {\n\t    return function () {\n\t        if (typeof console !== \"undefined\" &&\n\t            typeof console.warn === \"function\") {\n\t            console.warn(name + \" is deprecated, use \" + alternative +\n\t                         \" instead.\", new Error(\"\").stack);\n\t        }\n\t        return callback.apply(callback, arguments);\n\t    };\n\t}\n\t\n\t// end of shims\n\t// beginning of real work\n\t\n\t/**\n\t * Constructs a promise for an immediate reference, passes promises through, or\n\t * coerces promises from different systems.\n\t * @param value immediate reference or promise\n\t */\n\tfunction Q(value) {\n\t    // If the object is already a Promise, return it directly.  This enables\n\t    // the resolve function to both be used to created references from objects,\n\t    // but to tolerably coerce non-promises to promises.\n\t    if (value instanceof Promise) {\n\t        return value;\n\t    }\n\t\n\t    // assimilate thenables\n\t    if (isPromiseAlike(value)) {\n\t        return coerce(value);\n\t    } else {\n\t        return fulfill(value);\n\t    }\n\t}\n\tQ.resolve = Q;\n\t\n\t/**\n\t * Performs a task in a future turn of the event loop.\n\t * @param {Function} task\n\t */\n\tQ.nextTick = nextTick;\n\t\n\t/**\n\t * Controls whether or not long stack traces will be on\n\t */\n\tQ.longStackSupport = false;\n\t\n\t/**\n\t * The counter is used to determine the stopping point for building\n\t * long stack traces. In makeStackTraceLong we walk backwards through\n\t * the linked list of promises, only stacks which were created before\n\t * the rejection are concatenated.\n\t */\n\tvar longStackCounter = 1;\n\t\n\t// enable long stacks if Q_DEBUG is set\n\tif (typeof process === \"object\" && process && ({\"NODE_ENV\":\"production\"}) && ({\"NODE_ENV\":\"production\"}).Q_DEBUG) {\n\t    Q.longStackSupport = true;\n\t}\n\t\n\t/**\n\t * Constructs a {promise, resolve, reject} object.\n\t *\n\t * `resolve` is a callback to invoke with a more resolved value for the\n\t * promise. To fulfill the promise, invoke `resolve` with any value that is\n\t * not a thenable. To reject the promise, invoke `resolve` with a rejected\n\t * thenable, or invoke `reject` with the reason directly. To resolve the\n\t * promise to another thenable, thus putting it in the same state, invoke\n\t * `resolve` with that other thenable.\n\t */\n\tQ.defer = defer;\n\tfunction defer() {\n\t    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n\t    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n\t    // element of the messages array is itself an array of complete arguments to\n\t    // forward to the resolved promise.  We coerce the resolution value to a\n\t    // promise using the `resolve` function because it handles both fully\n\t    // non-thenable values and other thenables gracefully.\n\t    var messages = [], progressListeners = [], resolvedPromise;\n\t\n\t    var deferred = object_create(defer.prototype);\n\t    var promise = object_create(Promise.prototype);\n\t\n\t    promise.promiseDispatch = function (resolve, op, operands) {\n\t        var args = array_slice(arguments);\n\t        if (messages) {\n\t            messages.push(args);\n\t            if (op === \"when\" && operands[1]) { // progress operand\n\t                progressListeners.push(operands[1]);\n\t            }\n\t        } else {\n\t            Q.nextTick(function () {\n\t                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n\t            });\n\t        }\n\t    };\n\t\n\t    // XXX deprecated\n\t    promise.valueOf = function () {\n\t        if (messages) {\n\t            return promise;\n\t        }\n\t        var nearerValue = nearer(resolvedPromise);\n\t        if (isPromise(nearerValue)) {\n\t            resolvedPromise = nearerValue; // shorten chain\n\t        }\n\t        return nearerValue;\n\t    };\n\t\n\t    promise.inspect = function () {\n\t        if (!resolvedPromise) {\n\t            return { state: \"pending\" };\n\t        }\n\t        return resolvedPromise.inspect();\n\t    };\n\t\n\t    if (Q.longStackSupport && hasStacks) {\n\t        try {\n\t            throw new Error();\n\t        } catch (e) {\n\t            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n\t            // accessor around; that causes memory leaks as per GH-111. Just\n\t            // reify the stack trace as a string ASAP.\n\t            //\n\t            // At the same time, cut off the first line; it's always just\n\t            // \"[object Promise]\\n\", as per the `toString`.\n\t            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n\t            promise.stackCounter = longStackCounter++;\n\t        }\n\t    }\n\t\n\t    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n\t    // consolidating them into `become`, since otherwise we'd create new\n\t    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\t\n\t    function become(newPromise) {\n\t        resolvedPromise = newPromise;\n\t\n\t        if (Q.longStackSupport && hasStacks) {\n\t            // Only hold a reference to the new promise if long stacks\n\t            // are enabled to reduce memory usage\n\t            promise.source = newPromise;\n\t        }\n\t\n\t        array_reduce(messages, function (undefined, message) {\n\t            Q.nextTick(function () {\n\t                newPromise.promiseDispatch.apply(newPromise, message);\n\t            });\n\t        }, void 0);\n\t\n\t        messages = void 0;\n\t        progressListeners = void 0;\n\t    }\n\t\n\t    deferred.promise = promise;\n\t    deferred.resolve = function (value) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        become(Q(value));\n\t    };\n\t\n\t    deferred.fulfill = function (value) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        become(fulfill(value));\n\t    };\n\t    deferred.reject = function (reason) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        become(reject(reason));\n\t    };\n\t    deferred.notify = function (progress) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        array_reduce(progressListeners, function (undefined, progressListener) {\n\t            Q.nextTick(function () {\n\t                progressListener(progress);\n\t            });\n\t        }, void 0);\n\t    };\n\t\n\t    return deferred;\n\t}\n\t\n\t/**\n\t * Creates a Node-style callback that will resolve or reject the deferred\n\t * promise.\n\t * @returns a nodeback\n\t */\n\tdefer.prototype.makeNodeResolver = function () {\n\t    var self = this;\n\t    return function (error, value) {\n\t        if (error) {\n\t            self.reject(error);\n\t        } else if (arguments.length > 2) {\n\t            self.resolve(array_slice(arguments, 1));\n\t        } else {\n\t            self.resolve(value);\n\t        }\n\t    };\n\t};\n\t\n\t/**\n\t * @param resolver {Function} a function that returns nothing and accepts\n\t * the resolve, reject, and notify functions for a deferred.\n\t * @returns a promise that may be resolved with the given resolve and reject\n\t * functions, or rejected by a thrown exception in resolver\n\t */\n\tQ.Promise = promise; // ES6\n\tQ.promise = promise;\n\tfunction promise(resolver) {\n\t    if (typeof resolver !== \"function\") {\n\t        throw new TypeError(\"resolver must be a function.\");\n\t    }\n\t    var deferred = defer();\n\t    try {\n\t        resolver(deferred.resolve, deferred.reject, deferred.notify);\n\t    } catch (reason) {\n\t        deferred.reject(reason);\n\t    }\n\t    return deferred.promise;\n\t}\n\t\n\tpromise.race = race; // ES6\n\tpromise.all = all; // ES6\n\tpromise.reject = reject; // ES6\n\tpromise.resolve = Q; // ES6\n\t\n\t// XXX experimental.  This method is a way to denote that a local value is\n\t// serializable and should be immediately dispatched to a remote upon request,\n\t// instead of passing a reference.\n\tQ.passByCopy = function (object) {\n\t    //freeze(object);\n\t    //passByCopies.set(object, true);\n\t    return object;\n\t};\n\t\n\tPromise.prototype.passByCopy = function () {\n\t    //freeze(object);\n\t    //passByCopies.set(object, true);\n\t    return this;\n\t};\n\t\n\t/**\n\t * If two promises eventually fulfill to the same value, promises that value,\n\t * but otherwise rejects.\n\t * @param x {Any*}\n\t * @param y {Any*}\n\t * @returns {Any*} a promise for x and y if they are the same, but a rejection\n\t * otherwise.\n\t *\n\t */\n\tQ.join = function (x, y) {\n\t    return Q(x).join(y);\n\t};\n\t\n\tPromise.prototype.join = function (that) {\n\t    return Q([this, that]).spread(function (x, y) {\n\t        if (x === y) {\n\t            // TODO: \"===\" should be Object.is or equiv\n\t            return x;\n\t        } else {\n\t            throw new Error(\"Q can't join: not the same: \" + x + \" \" + y);\n\t        }\n\t    });\n\t};\n\t\n\t/**\n\t * Returns a promise for the first of an array of promises to become settled.\n\t * @param answers {Array[Any*]} promises to race\n\t * @returns {Any*} the first promise to be settled\n\t */\n\tQ.race = race;\n\tfunction race(answerPs) {\n\t    return promise(function (resolve, reject) {\n\t        // Switch to this once we can assume at least ES5\n\t        // answerPs.forEach(function (answerP) {\n\t        //     Q(answerP).then(resolve, reject);\n\t        // });\n\t        // Use this in the meantime\n\t        for (var i = 0, len = answerPs.length; i < len; i++) {\n\t            Q(answerPs[i]).then(resolve, reject);\n\t        }\n\t    });\n\t}\n\t\n\tPromise.prototype.race = function () {\n\t    return this.then(Q.race);\n\t};\n\t\n\t/**\n\t * Constructs a Promise with a promise descriptor object and optional fallback\n\t * function.  The descriptor contains methods like when(rejected), get(name),\n\t * set(name, value), post(name, args), and delete(name), which all\n\t * return either a value, a promise for a value, or a rejection.  The fallback\n\t * accepts the operation name, a resolver, and any further arguments that would\n\t * have been forwarded to the appropriate method above had a method been\n\t * provided with the proper name.  The API makes no guarantees about the nature\n\t * of the returned object, apart from that it is usable whereever promises are\n\t * bought and sold.\n\t */\n\tQ.makePromise = Promise;\n\tfunction Promise(descriptor, fallback, inspect) {\n\t    if (fallback === void 0) {\n\t        fallback = function (op) {\n\t            return reject(new Error(\n\t                \"Promise does not support operation: \" + op\n\t            ));\n\t        };\n\t    }\n\t    if (inspect === void 0) {\n\t        inspect = function () {\n\t            return {state: \"unknown\"};\n\t        };\n\t    }\n\t\n\t    var promise = object_create(Promise.prototype);\n\t\n\t    promise.promiseDispatch = function (resolve, op, args) {\n\t        var result;\n\t        try {\n\t            if (descriptor[op]) {\n\t                result = descriptor[op].apply(promise, args);\n\t            } else {\n\t                result = fallback.call(promise, op, args);\n\t            }\n\t        } catch (exception) {\n\t            result = reject(exception);\n\t        }\n\t        if (resolve) {\n\t            resolve(result);\n\t        }\n\t    };\n\t\n\t    promise.inspect = inspect;\n\t\n\t    // XXX deprecated `valueOf` and `exception` support\n\t    if (inspect) {\n\t        var inspected = inspect();\n\t        if (inspected.state === \"rejected\") {\n\t            promise.exception = inspected.reason;\n\t        }\n\t\n\t        promise.valueOf = function () {\n\t            var inspected = inspect();\n\t            if (inspected.state === \"pending\" ||\n\t                inspected.state === \"rejected\") {\n\t                return promise;\n\t            }\n\t            return inspected.value;\n\t        };\n\t    }\n\t\n\t    return promise;\n\t}\n\t\n\tPromise.prototype.toString = function () {\n\t    return \"[object Promise]\";\n\t};\n\t\n\tPromise.prototype.then = function (fulfilled, rejected, progressed) {\n\t    var self = this;\n\t    var deferred = defer();\n\t    var done = false;   // ensure the untrusted promise makes at most a\n\t                        // single call to one of the callbacks\n\t\n\t    function _fulfilled(value) {\n\t        try {\n\t            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n\t        } catch (exception) {\n\t            return reject(exception);\n\t        }\n\t    }\n\t\n\t    function _rejected(exception) {\n\t        if (typeof rejected === \"function\") {\n\t            makeStackTraceLong(exception, self);\n\t            try {\n\t                return rejected(exception);\n\t            } catch (newException) {\n\t                return reject(newException);\n\t            }\n\t        }\n\t        return reject(exception);\n\t    }\n\t\n\t    function _progressed(value) {\n\t        return typeof progressed === \"function\" ? progressed(value) : value;\n\t    }\n\t\n\t    Q.nextTick(function () {\n\t        self.promiseDispatch(function (value) {\n\t            if (done) {\n\t                return;\n\t            }\n\t            done = true;\n\t\n\t            deferred.resolve(_fulfilled(value));\n\t        }, \"when\", [function (exception) {\n\t            if (done) {\n\t                return;\n\t            }\n\t            done = true;\n\t\n\t            deferred.resolve(_rejected(exception));\n\t        }]);\n\t    });\n\t\n\t    // Progress propagator need to be attached in the current tick.\n\t    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n\t        var newValue;\n\t        var threw = false;\n\t        try {\n\t            newValue = _progressed(value);\n\t        } catch (e) {\n\t            threw = true;\n\t            if (Q.onerror) {\n\t                Q.onerror(e);\n\t            } else {\n\t                throw e;\n\t            }\n\t        }\n\t\n\t        if (!threw) {\n\t            deferred.notify(newValue);\n\t        }\n\t    }]);\n\t\n\t    return deferred.promise;\n\t};\n\t\n\tQ.tap = function (promise, callback) {\n\t    return Q(promise).tap(callback);\n\t};\n\t\n\t/**\n\t * Works almost like \"finally\", but not called for rejections.\n\t * Original resolution value is passed through callback unaffected.\n\t * Callback may return a promise that will be awaited for.\n\t * @param {Function} callback\n\t * @returns {Q.Promise}\n\t * @example\n\t * doSomething()\n\t *   .then(...)\n\t *   .tap(console.log)\n\t *   .then(...);\n\t */\n\tPromise.prototype.tap = function (callback) {\n\t    callback = Q(callback);\n\t\n\t    return this.then(function (value) {\n\t        return callback.fcall(value).thenResolve(value);\n\t    });\n\t};\n\t\n\t/**\n\t * Registers an observer on a promise.\n\t *\n\t * Guarantees:\n\t *\n\t * 1. that fulfilled and rejected will be called only once.\n\t * 2. that either the fulfilled callback or the rejected callback will be\n\t *    called, but not both.\n\t * 3. that fulfilled and rejected will not be called in this turn.\n\t *\n\t * @param value      promise or immediate reference to observe\n\t * @param fulfilled  function to be called with the fulfilled value\n\t * @param rejected   function to be called with the rejection exception\n\t * @param progressed function to be called on any progress notifications\n\t * @return promise for the return value from the invoked callback\n\t */\n\tQ.when = when;\n\tfunction when(value, fulfilled, rejected, progressed) {\n\t    return Q(value).then(fulfilled, rejected, progressed);\n\t}\n\t\n\tPromise.prototype.thenResolve = function (value) {\n\t    return this.then(function () { return value; });\n\t};\n\t\n\tQ.thenResolve = function (promise, value) {\n\t    return Q(promise).thenResolve(value);\n\t};\n\t\n\tPromise.prototype.thenReject = function (reason) {\n\t    return this.then(function () { throw reason; });\n\t};\n\t\n\tQ.thenReject = function (promise, reason) {\n\t    return Q(promise).thenReject(reason);\n\t};\n\t\n\t/**\n\t * If an object is not a promise, it is as \"near\" as possible.\n\t * If a promise is rejected, it is as \"near\" as possible too.\n\t * If it’s a fulfilled promise, the fulfillment value is nearer.\n\t * If it’s a deferred promise and the deferred has been resolved, the\n\t * resolution is \"nearer\".\n\t * @param object\n\t * @returns most resolved (nearest) form of the object\n\t */\n\t\n\t// XXX should we re-do this?\n\tQ.nearer = nearer;\n\tfunction nearer(value) {\n\t    if (isPromise(value)) {\n\t        var inspected = value.inspect();\n\t        if (inspected.state === \"fulfilled\") {\n\t            return inspected.value;\n\t        }\n\t    }\n\t    return value;\n\t}\n\t\n\t/**\n\t * @returns whether the given object is a promise.\n\t * Otherwise it is a fulfilled value.\n\t */\n\tQ.isPromise = isPromise;\n\tfunction isPromise(object) {\n\t    return object instanceof Promise;\n\t}\n\t\n\tQ.isPromiseAlike = isPromiseAlike;\n\tfunction isPromiseAlike(object) {\n\t    return isObject(object) && typeof object.then === \"function\";\n\t}\n\t\n\t/**\n\t * @returns whether the given object is a pending promise, meaning not\n\t * fulfilled or rejected.\n\t */\n\tQ.isPending = isPending;\n\tfunction isPending(object) {\n\t    return isPromise(object) && object.inspect().state === \"pending\";\n\t}\n\t\n\tPromise.prototype.isPending = function () {\n\t    return this.inspect().state === \"pending\";\n\t};\n\t\n\t/**\n\t * @returns whether the given object is a value or fulfilled\n\t * promise.\n\t */\n\tQ.isFulfilled = isFulfilled;\n\tfunction isFulfilled(object) {\n\t    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n\t}\n\t\n\tPromise.prototype.isFulfilled = function () {\n\t    return this.inspect().state === \"fulfilled\";\n\t};\n\t\n\t/**\n\t * @returns whether the given object is a rejected promise.\n\t */\n\tQ.isRejected = isRejected;\n\tfunction isRejected(object) {\n\t    return isPromise(object) && object.inspect().state === \"rejected\";\n\t}\n\t\n\tPromise.prototype.isRejected = function () {\n\t    return this.inspect().state === \"rejected\";\n\t};\n\t\n\t//// BEGIN UNHANDLED REJECTION TRACKING\n\t\n\t// This promise library consumes exceptions thrown in handlers so they can be\n\t// handled by a subsequent promise.  The exceptions get added to this array when\n\t// they are created, and removed when they are handled.  Note that in ES6 or\n\t// shimmed environments, this would naturally be a `Set`.\n\tvar unhandledReasons = [];\n\tvar unhandledRejections = [];\n\tvar reportedUnhandledRejections = [];\n\tvar trackUnhandledRejections = true;\n\t\n\tfunction resetUnhandledRejections() {\n\t    unhandledReasons.length = 0;\n\t    unhandledRejections.length = 0;\n\t\n\t    if (!trackUnhandledRejections) {\n\t        trackUnhandledRejections = true;\n\t    }\n\t}\n\t\n\tfunction trackRejection(promise, reason) {\n\t    if (!trackUnhandledRejections) {\n\t        return;\n\t    }\n\t    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n\t        Q.nextTick.runAfter(function () {\n\t            if (array_indexOf(unhandledRejections, promise) !== -1) {\n\t                process.emit(\"unhandledRejection\", reason, promise);\n\t                reportedUnhandledRejections.push(promise);\n\t            }\n\t        });\n\t    }\n\t\n\t    unhandledRejections.push(promise);\n\t    if (reason && typeof reason.stack !== \"undefined\") {\n\t        unhandledReasons.push(reason.stack);\n\t    } else {\n\t        unhandledReasons.push(\"(no stack) \" + reason);\n\t    }\n\t}\n\t\n\tfunction untrackRejection(promise) {\n\t    if (!trackUnhandledRejections) {\n\t        return;\n\t    }\n\t\n\t    var at = array_indexOf(unhandledRejections, promise);\n\t    if (at !== -1) {\n\t        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n\t            Q.nextTick.runAfter(function () {\n\t                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n\t                if (atReport !== -1) {\n\t                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n\t                    reportedUnhandledRejections.splice(atReport, 1);\n\t                }\n\t            });\n\t        }\n\t        unhandledRejections.splice(at, 1);\n\t        unhandledReasons.splice(at, 1);\n\t    }\n\t}\n\t\n\tQ.resetUnhandledRejections = resetUnhandledRejections;\n\t\n\tQ.getUnhandledReasons = function () {\n\t    // Make a copy so that consumers can't interfere with our internal state.\n\t    return unhandledReasons.slice();\n\t};\n\t\n\tQ.stopUnhandledRejectionTracking = function () {\n\t    resetUnhandledRejections();\n\t    trackUnhandledRejections = false;\n\t};\n\t\n\tresetUnhandledRejections();\n\t\n\t//// END UNHANDLED REJECTION TRACKING\n\t\n\t/**\n\t * Constructs a rejected promise.\n\t * @param reason value describing the failure\n\t */\n\tQ.reject = reject;\n\tfunction reject(reason) {\n\t    var rejection = Promise({\n\t        \"when\": function (rejected) {\n\t            // note that the error has been handled\n\t            if (rejected) {\n\t                untrackRejection(this);\n\t            }\n\t            return rejected ? rejected(reason) : this;\n\t        }\n\t    }, function fallback() {\n\t        return this;\n\t    }, function inspect() {\n\t        return { state: \"rejected\", reason: reason };\n\t    });\n\t\n\t    // Note that the reason has not been handled.\n\t    trackRejection(rejection, reason);\n\t\n\t    return rejection;\n\t}\n\t\n\t/**\n\t * Constructs a fulfilled promise for an immediate reference.\n\t * @param value immediate reference\n\t */\n\tQ.fulfill = fulfill;\n\tfunction fulfill(value) {\n\t    return Promise({\n\t        \"when\": function () {\n\t            return value;\n\t        },\n\t        \"get\": function (name) {\n\t            return value[name];\n\t        },\n\t        \"set\": function (name, rhs) {\n\t            value[name] = rhs;\n\t        },\n\t        \"delete\": function (name) {\n\t            delete value[name];\n\t        },\n\t        \"post\": function (name, args) {\n\t            // Mark Miller proposes that post with no name should apply a\n\t            // promised function.\n\t            if (name === null || name === void 0) {\n\t                return value.apply(void 0, args);\n\t            } else {\n\t                return value[name].apply(value, args);\n\t            }\n\t        },\n\t        \"apply\": function (thisp, args) {\n\t            return value.apply(thisp, args);\n\t        },\n\t        \"keys\": function () {\n\t            return object_keys(value);\n\t        }\n\t    }, void 0, function inspect() {\n\t        return { state: \"fulfilled\", value: value };\n\t    });\n\t}\n\t\n\t/**\n\t * Converts thenables to Q promises.\n\t * @param promise thenable promise\n\t * @returns a Q promise\n\t */\n\tfunction coerce(promise) {\n\t    var deferred = defer();\n\t    Q.nextTick(function () {\n\t        try {\n\t            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n\t        } catch (exception) {\n\t            deferred.reject(exception);\n\t        }\n\t    });\n\t    return deferred.promise;\n\t}\n\t\n\t/**\n\t * Annotates an object such that it will never be\n\t * transferred away from this process over any promise\n\t * communication channel.\n\t * @param object\n\t * @returns promise a wrapping of that object that\n\t * additionally responds to the \"isDef\" message\n\t * without a rejection.\n\t */\n\tQ.master = master;\n\tfunction master(object) {\n\t    return Promise({\n\t        \"isDef\": function () {}\n\t    }, function fallback(op, args) {\n\t        return dispatch(object, op, args);\n\t    }, function () {\n\t        return Q(object).inspect();\n\t    });\n\t}\n\t\n\t/**\n\t * Spreads the values of a promised array of arguments into the\n\t * fulfillment callback.\n\t * @param fulfilled callback that receives variadic arguments from the\n\t * promised array\n\t * @param rejected callback that receives the exception if the promise\n\t * is rejected.\n\t * @returns a promise for the return value or thrown exception of\n\t * either callback.\n\t */\n\tQ.spread = spread;\n\tfunction spread(value, fulfilled, rejected) {\n\t    return Q(value).spread(fulfilled, rejected);\n\t}\n\t\n\tPromise.prototype.spread = function (fulfilled, rejected) {\n\t    return this.all().then(function (array) {\n\t        return fulfilled.apply(void 0, array);\n\t    }, rejected);\n\t};\n\t\n\t/**\n\t * The async function is a decorator for generator functions, turning\n\t * them into asynchronous generators.  Although generators are only part\n\t * of the newest ECMAScript 6 drafts, this code does not cause syntax\n\t * errors in older engines.  This code should continue to work and will\n\t * in fact improve over time as the language improves.\n\t *\n\t * ES6 generators are currently part of V8 version 3.19 with the\n\t * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n\t * for longer, but under an older Python-inspired form.  This function\n\t * works on both kinds of generators.\n\t *\n\t * Decorates a generator function such that:\n\t *  - it may yield promises\n\t *  - execution will continue when that promise is fulfilled\n\t *  - the value of the yield expression will be the fulfilled value\n\t *  - it returns a promise for the return value (when the generator\n\t *    stops iterating)\n\t *  - the decorated function returns a promise for the return value\n\t *    of the generator or the first rejected promise among those\n\t *    yielded.\n\t *  - if an error is thrown in the generator, it propagates through\n\t *    every following yield until it is caught, or until it escapes\n\t *    the generator function altogether, and is translated into a\n\t *    rejection for the promise returned by the decorated generator.\n\t */\n\tQ.async = async;\n\tfunction async(makeGenerator) {\n\t    return function () {\n\t        // when verb is \"send\", arg is a value\n\t        // when verb is \"throw\", arg is an exception\n\t        function continuer(verb, arg) {\n\t            var result;\n\t\n\t            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n\t            // engine that has a deployed base of browsers that support generators.\n\t            // However, SM's generators use the Python-inspired semantics of\n\t            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n\t            // like to make it possible to use generators in deployed browsers, so\n\t            // we also support Python-style generators.  At some point we can remove\n\t            // this block.\n\t\n\t            if (typeof StopIteration === \"undefined\") {\n\t                // ES6 Generators\n\t                try {\n\t                    result = generator[verb](arg);\n\t                } catch (exception) {\n\t                    return reject(exception);\n\t                }\n\t                if (result.done) {\n\t                    return Q(result.value);\n\t                } else {\n\t                    return when(result.value, callback, errback);\n\t                }\n\t            } else {\n\t                // SpiderMonkey Generators\n\t                // FIXME: Remove this case when SM does ES6 generators.\n\t                try {\n\t                    result = generator[verb](arg);\n\t                } catch (exception) {\n\t                    if (isStopIteration(exception)) {\n\t                        return Q(exception.value);\n\t                    } else {\n\t                        return reject(exception);\n\t                    }\n\t                }\n\t                return when(result, callback, errback);\n\t            }\n\t        }\n\t        var generator = makeGenerator.apply(this, arguments);\n\t        var callback = continuer.bind(continuer, \"next\");\n\t        var errback = continuer.bind(continuer, \"throw\");\n\t        return callback();\n\t    };\n\t}\n\t\n\t/**\n\t * The spawn function is a small wrapper around async that immediately\n\t * calls the generator and also ends the promise chain, so that any\n\t * unhandled errors are thrown instead of forwarded to the error\n\t * handler. This is useful because it's extremely common to run\n\t * generators at the top-level to work with libraries.\n\t */\n\tQ.spawn = spawn;\n\tfunction spawn(makeGenerator) {\n\t    Q.done(Q.async(makeGenerator)());\n\t}\n\t\n\t// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n\t/**\n\t * Throws a ReturnValue exception to stop an asynchronous generator.\n\t *\n\t * This interface is a stop-gap measure to support generator return\n\t * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n\t * generators like Chromium 29, just use \"return\" in your generator\n\t * functions.\n\t *\n\t * @param value the return value for the surrounding generator\n\t * @throws ReturnValue exception with the value.\n\t * @example\n\t * // ES6 style\n\t * Q.async(function* () {\n\t *      var foo = yield getFooPromise();\n\t *      var bar = yield getBarPromise();\n\t *      return foo + bar;\n\t * })\n\t * // Older SpiderMonkey style\n\t * Q.async(function () {\n\t *      var foo = yield getFooPromise();\n\t *      var bar = yield getBarPromise();\n\t *      Q.return(foo + bar);\n\t * })\n\t */\n\tQ[\"return\"] = _return;\n\tfunction _return(value) {\n\t    throw new QReturnValue(value);\n\t}\n\t\n\t/**\n\t * The promised function decorator ensures that any promise arguments\n\t * are settled and passed as values (`this` is also settled and passed\n\t * as a value).  It will also ensure that the result of a function is\n\t * always a promise.\n\t *\n\t * @example\n\t * var add = Q.promised(function (a, b) {\n\t *     return a + b;\n\t * });\n\t * add(Q(a), Q(B));\n\t *\n\t * @param {function} callback The function to decorate\n\t * @returns {function} a function that has been decorated.\n\t */\n\tQ.promised = promised;\n\tfunction promised(callback) {\n\t    return function () {\n\t        return spread([this, all(arguments)], function (self, args) {\n\t            return callback.apply(self, args);\n\t        });\n\t    };\n\t}\n\t\n\t/**\n\t * sends a message to a value in a future turn\n\t * @param object* the recipient\n\t * @param op the name of the message operation, e.g., \"when\",\n\t * @param args further arguments to be forwarded to the operation\n\t * @returns result {Promise} a promise for the result of the operation\n\t */\n\tQ.dispatch = dispatch;\n\tfunction dispatch(object, op, args) {\n\t    return Q(object).dispatch(op, args);\n\t}\n\t\n\tPromise.prototype.dispatch = function (op, args) {\n\t    var self = this;\n\t    var deferred = defer();\n\t    Q.nextTick(function () {\n\t        self.promiseDispatch(deferred.resolve, op, args);\n\t    });\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Gets the value of a property in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of property to get\n\t * @return promise for the property value\n\t */\n\tQ.get = function (object, key) {\n\t    return Q(object).dispatch(\"get\", [key]);\n\t};\n\t\n\tPromise.prototype.get = function (key) {\n\t    return this.dispatch(\"get\", [key]);\n\t};\n\t\n\t/**\n\t * Sets the value of a property in a future turn.\n\t * @param object    promise or immediate reference for object object\n\t * @param name      name of property to set\n\t * @param value     new value of property\n\t * @return promise for the return value\n\t */\n\tQ.set = function (object, key, value) {\n\t    return Q(object).dispatch(\"set\", [key, value]);\n\t};\n\t\n\tPromise.prototype.set = function (key, value) {\n\t    return this.dispatch(\"set\", [key, value]);\n\t};\n\t\n\t/**\n\t * Deletes a property in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of property to delete\n\t * @return promise for the return value\n\t */\n\tQ.del = // XXX legacy\n\tQ[\"delete\"] = function (object, key) {\n\t    return Q(object).dispatch(\"delete\", [key]);\n\t};\n\t\n\tPromise.prototype.del = // XXX legacy\n\tPromise.prototype[\"delete\"] = function (key) {\n\t    return this.dispatch(\"delete\", [key]);\n\t};\n\t\n\t/**\n\t * Invokes a method in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of method to invoke\n\t * @param value     a value to post, typically an array of\n\t *                  invocation arguments for promises that\n\t *                  are ultimately backed with `resolve` values,\n\t *                  as opposed to those backed with URLs\n\t *                  wherein the posted value can be any\n\t *                  JSON serializable object.\n\t * @return promise for the return value\n\t */\n\t// bound locally because it is used by other methods\n\tQ.mapply = // XXX As proposed by \"Redsandro\"\n\tQ.post = function (object, name, args) {\n\t    return Q(object).dispatch(\"post\", [name, args]);\n\t};\n\t\n\tPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\n\tPromise.prototype.post = function (name, args) {\n\t    return this.dispatch(\"post\", [name, args]);\n\t};\n\t\n\t/**\n\t * Invokes a method in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of method to invoke\n\t * @param ...args   array of invocation arguments\n\t * @return promise for the return value\n\t */\n\tQ.send = // XXX Mark Miller's proposed parlance\n\tQ.mcall = // XXX As proposed by \"Redsandro\"\n\tQ.invoke = function (object, name /*...args*/) {\n\t    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n\t};\n\t\n\tPromise.prototype.send = // XXX Mark Miller's proposed parlance\n\tPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\n\tPromise.prototype.invoke = function (name /*...args*/) {\n\t    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n\t};\n\t\n\t/**\n\t * Applies the promised function in a future turn.\n\t * @param object    promise or immediate reference for target function\n\t * @param args      array of application arguments\n\t */\n\tQ.fapply = function (object, args) {\n\t    return Q(object).dispatch(\"apply\", [void 0, args]);\n\t};\n\t\n\tPromise.prototype.fapply = function (args) {\n\t    return this.dispatch(\"apply\", [void 0, args]);\n\t};\n\t\n\t/**\n\t * Calls the promised function in a future turn.\n\t * @param object    promise or immediate reference for target function\n\t * @param ...args   array of application arguments\n\t */\n\tQ[\"try\"] =\n\tQ.fcall = function (object /* ...args*/) {\n\t    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n\t};\n\t\n\tPromise.prototype.fcall = function (/*...args*/) {\n\t    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n\t};\n\t\n\t/**\n\t * Binds the promised function, transforming return values into a fulfilled\n\t * promise and thrown errors into a rejected one.\n\t * @param object    promise or immediate reference for target function\n\t * @param ...args   array of application arguments\n\t */\n\tQ.fbind = function (object /*...args*/) {\n\t    var promise = Q(object);\n\t    var args = array_slice(arguments, 1);\n\t    return function fbound() {\n\t        return promise.dispatch(\"apply\", [\n\t            this,\n\t            args.concat(array_slice(arguments))\n\t        ]);\n\t    };\n\t};\n\tPromise.prototype.fbind = function (/*...args*/) {\n\t    var promise = this;\n\t    var args = array_slice(arguments);\n\t    return function fbound() {\n\t        return promise.dispatch(\"apply\", [\n\t            this,\n\t            args.concat(array_slice(arguments))\n\t        ]);\n\t    };\n\t};\n\t\n\t/**\n\t * Requests the names of the owned properties of a promised\n\t * object in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @return promise for the keys of the eventually settled object\n\t */\n\tQ.keys = function (object) {\n\t    return Q(object).dispatch(\"keys\", []);\n\t};\n\t\n\tPromise.prototype.keys = function () {\n\t    return this.dispatch(\"keys\", []);\n\t};\n\t\n\t/**\n\t * Turns an array of promises into a promise for an array.  If any of\n\t * the promises gets rejected, the whole array is rejected immediately.\n\t * @param {Array*} an array (or promise for an array) of values (or\n\t * promises for values)\n\t * @returns a promise for an array of the corresponding values\n\t */\n\t// By Mark Miller\n\t// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\n\tQ.all = all;\n\tfunction all(promises) {\n\t    return when(promises, function (promises) {\n\t        var pendingCount = 0;\n\t        var deferred = defer();\n\t        array_reduce(promises, function (undefined, promise, index) {\n\t            var snapshot;\n\t            if (\n\t                isPromise(promise) &&\n\t                (snapshot = promise.inspect()).state === \"fulfilled\"\n\t            ) {\n\t                promises[index] = snapshot.value;\n\t            } else {\n\t                ++pendingCount;\n\t                when(\n\t                    promise,\n\t                    function (value) {\n\t                        promises[index] = value;\n\t                        if (--pendingCount === 0) {\n\t                            deferred.resolve(promises);\n\t                        }\n\t                    },\n\t                    deferred.reject,\n\t                    function (progress) {\n\t                        deferred.notify({ index: index, value: progress });\n\t                    }\n\t                );\n\t            }\n\t        }, void 0);\n\t        if (pendingCount === 0) {\n\t            deferred.resolve(promises);\n\t        }\n\t        return deferred.promise;\n\t    });\n\t}\n\t\n\tPromise.prototype.all = function () {\n\t    return all(this);\n\t};\n\t\n\t/**\n\t * Returns the first resolved promise of an array. Prior rejected promises are\n\t * ignored.  Rejects only if all promises are rejected.\n\t * @param {Array*} an array containing values or promises for values\n\t * @returns a promise fulfilled with the value of the first resolved promise,\n\t * or a rejected promise if all promises are rejected.\n\t */\n\tQ.any = any;\n\t\n\tfunction any(promises) {\n\t    if (promises.length === 0) {\n\t        return Q.resolve();\n\t    }\n\t\n\t    var deferred = Q.defer();\n\t    var pendingCount = 0;\n\t    array_reduce(promises, function (prev, current, index) {\n\t        var promise = promises[index];\n\t\n\t        pendingCount++;\n\t\n\t        when(promise, onFulfilled, onRejected, onProgress);\n\t        function onFulfilled(result) {\n\t            deferred.resolve(result);\n\t        }\n\t        function onRejected(err) {\n\t            pendingCount--;\n\t            if (pendingCount === 0) {\n\t                err.message = (\"Q can't get fulfillment value from any promise, all \" +\n\t                    \"promises were rejected. Last error message: \" + err.message);\n\t                deferred.reject(err);\n\t            }\n\t        }\n\t        function onProgress(progress) {\n\t            deferred.notify({\n\t                index: index,\n\t                value: progress\n\t            });\n\t        }\n\t    }, undefined);\n\t\n\t    return deferred.promise;\n\t}\n\t\n\tPromise.prototype.any = function () {\n\t    return any(this);\n\t};\n\t\n\t/**\n\t * Waits for all promises to be settled, either fulfilled or\n\t * rejected.  This is distinct from `all` since that would stop\n\t * waiting at the first rejection.  The promise returned by\n\t * `allResolved` will never be rejected.\n\t * @param promises a promise for an array (or an array) of promises\n\t * (or values)\n\t * @return a promise for an array of promises\n\t */\n\tQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\n\tfunction allResolved(promises) {\n\t    return when(promises, function (promises) {\n\t        promises = array_map(promises, Q);\n\t        return when(all(array_map(promises, function (promise) {\n\t            return when(promise, noop, noop);\n\t        })), function () {\n\t            return promises;\n\t        });\n\t    });\n\t}\n\t\n\tPromise.prototype.allResolved = function () {\n\t    return allResolved(this);\n\t};\n\t\n\t/**\n\t * @see Promise#allSettled\n\t */\n\tQ.allSettled = allSettled;\n\tfunction allSettled(promises) {\n\t    return Q(promises).allSettled();\n\t}\n\t\n\t/**\n\t * Turns an array of promises into a promise for an array of their states (as\n\t * returned by `inspect`) when they have all settled.\n\t * @param {Array[Any*]} values an array (or promise for an array) of values (or\n\t * promises for values)\n\t * @returns {Array[State]} an array of states for the respective values.\n\t */\n\tPromise.prototype.allSettled = function () {\n\t    return this.then(function (promises) {\n\t        return all(array_map(promises, function (promise) {\n\t            promise = Q(promise);\n\t            function regardless() {\n\t                return promise.inspect();\n\t            }\n\t            return promise.then(regardless, regardless);\n\t        }));\n\t    });\n\t};\n\t\n\t/**\n\t * Captures the failure of a promise, giving an oportunity to recover\n\t * with a callback.  If the given promise is fulfilled, the returned\n\t * promise is fulfilled.\n\t * @param {Any*} promise for something\n\t * @param {Function} callback to fulfill the returned promise if the\n\t * given promise is rejected\n\t * @returns a promise for the return value of the callback\n\t */\n\tQ.fail = // XXX legacy\n\tQ[\"catch\"] = function (object, rejected) {\n\t    return Q(object).then(void 0, rejected);\n\t};\n\t\n\tPromise.prototype.fail = // XXX legacy\n\tPromise.prototype[\"catch\"] = function (rejected) {\n\t    return this.then(void 0, rejected);\n\t};\n\t\n\t/**\n\t * Attaches a listener that can respond to progress notifications from a\n\t * promise's originating deferred. This listener receives the exact arguments\n\t * passed to ``deferred.notify``.\n\t * @param {Any*} promise for something\n\t * @param {Function} callback to receive any progress notifications\n\t * @returns the given promise, unchanged\n\t */\n\tQ.progress = progress;\n\tfunction progress(object, progressed) {\n\t    return Q(object).then(void 0, void 0, progressed);\n\t}\n\t\n\tPromise.prototype.progress = function (progressed) {\n\t    return this.then(void 0, void 0, progressed);\n\t};\n\t\n\t/**\n\t * Provides an opportunity to observe the settling of a promise,\n\t * regardless of whether the promise is fulfilled or rejected.  Forwards\n\t * the resolution to the returned promise when the callback is done.\n\t * The callback can return a promise to defer completion.\n\t * @param {Any*} promise\n\t * @param {Function} callback to observe the resolution of the given\n\t * promise, takes no arguments.\n\t * @returns a promise for the resolution of the given promise when\n\t * ``fin`` is done.\n\t */\n\tQ.fin = // XXX legacy\n\tQ[\"finally\"] = function (object, callback) {\n\t    return Q(object)[\"finally\"](callback);\n\t};\n\t\n\tPromise.prototype.fin = // XXX legacy\n\tPromise.prototype[\"finally\"] = function (callback) {\n\t    if (!callback || typeof callback.apply !== \"function\") {\n\t        throw new Error(\"Q can't apply finally callback\");\n\t    }\n\t    callback = Q(callback);\n\t    return this.then(function (value) {\n\t        return callback.fcall().then(function () {\n\t            return value;\n\t        });\n\t    }, function (reason) {\n\t        // TODO attempt to recycle the rejection with \"this\".\n\t        return callback.fcall().then(function () {\n\t            throw reason;\n\t        });\n\t    });\n\t};\n\t\n\t/**\n\t * Terminates a chain of promises, forcing rejections to be\n\t * thrown as exceptions.\n\t * @param {Any*} promise at the end of a chain of promises\n\t * @returns nothing\n\t */\n\tQ.done = function (object, fulfilled, rejected, progress) {\n\t    return Q(object).done(fulfilled, rejected, progress);\n\t};\n\t\n\tPromise.prototype.done = function (fulfilled, rejected, progress) {\n\t    var onUnhandledError = function (error) {\n\t        // forward to a future turn so that ``when``\n\t        // does not catch it and turn it into a rejection.\n\t        Q.nextTick(function () {\n\t            makeStackTraceLong(error, promise);\n\t            if (Q.onerror) {\n\t                Q.onerror(error);\n\t            } else {\n\t                throw error;\n\t            }\n\t        });\n\t    };\n\t\n\t    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n\t    var promise = fulfilled || rejected || progress ?\n\t        this.then(fulfilled, rejected, progress) :\n\t        this;\n\t\n\t    if (typeof process === \"object\" && process && process.domain) {\n\t        onUnhandledError = process.domain.bind(onUnhandledError);\n\t    }\n\t\n\t    promise.then(void 0, onUnhandledError);\n\t};\n\t\n\t/**\n\t * Causes a promise to be rejected if it does not get fulfilled before\n\t * some milliseconds time out.\n\t * @param {Any*} promise\n\t * @param {Number} milliseconds timeout\n\t * @param {Any*} custom error message or Error object (optional)\n\t * @returns a promise for the resolution of the given promise if it is\n\t * fulfilled before the timeout, otherwise rejected.\n\t */\n\tQ.timeout = function (object, ms, error) {\n\t    return Q(object).timeout(ms, error);\n\t};\n\t\n\tPromise.prototype.timeout = function (ms, error) {\n\t    var deferred = defer();\n\t    var timeoutId = setTimeout(function () {\n\t        if (!error || \"string\" === typeof error) {\n\t            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n\t            error.code = \"ETIMEDOUT\";\n\t        }\n\t        deferred.reject(error);\n\t    }, ms);\n\t\n\t    this.then(function (value) {\n\t        clearTimeout(timeoutId);\n\t        deferred.resolve(value);\n\t    }, function (exception) {\n\t        clearTimeout(timeoutId);\n\t        deferred.reject(exception);\n\t    }, deferred.notify);\n\t\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Returns a promise for the given value (or promised value), some\n\t * milliseconds after it resolved. Passes rejections immediately.\n\t * @param {Any*} promise\n\t * @param {Number} milliseconds\n\t * @returns a promise for the resolution of the given promise after milliseconds\n\t * time has elapsed since the resolution of the given promise.\n\t * If the given promise rejects, that is passed immediately.\n\t */\n\tQ.delay = function (object, timeout) {\n\t    if (timeout === void 0) {\n\t        timeout = object;\n\t        object = void 0;\n\t    }\n\t    return Q(object).delay(timeout);\n\t};\n\t\n\tPromise.prototype.delay = function (timeout) {\n\t    return this.then(function (value) {\n\t        var deferred = defer();\n\t        setTimeout(function () {\n\t            deferred.resolve(value);\n\t        }, timeout);\n\t        return deferred.promise;\n\t    });\n\t};\n\t\n\t/**\n\t * Passes a continuation to a Node function, which is called with the given\n\t * arguments provided as an array, and returns a promise.\n\t *\n\t *      Q.nfapply(FS.readFile, [__filename])\n\t *      .then(function (content) {\n\t *      })\n\t *\n\t */\n\tQ.nfapply = function (callback, args) {\n\t    return Q(callback).nfapply(args);\n\t};\n\t\n\tPromise.prototype.nfapply = function (args) {\n\t    var deferred = defer();\n\t    var nodeArgs = array_slice(args);\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.fapply(nodeArgs).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Passes a continuation to a Node function, which is called with the given\n\t * arguments provided individually, and returns a promise.\n\t * @example\n\t * Q.nfcall(FS.readFile, __filename)\n\t * .then(function (content) {\n\t * })\n\t *\n\t */\n\tQ.nfcall = function (callback /*...args*/) {\n\t    var args = array_slice(arguments, 1);\n\t    return Q(callback).nfapply(args);\n\t};\n\t\n\tPromise.prototype.nfcall = function (/*...args*/) {\n\t    var nodeArgs = array_slice(arguments);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.fapply(nodeArgs).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Wraps a NodeJS continuation passing function and returns an equivalent\n\t * version that returns a promise.\n\t * @example\n\t * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n\t * .then(console.log)\n\t * .done()\n\t */\n\tQ.nfbind =\n\tQ.denodeify = function (callback /*...args*/) {\n\t    if (callback === undefined) {\n\t        throw new Error(\"Q can't wrap an undefined function\");\n\t    }\n\t    var baseArgs = array_slice(arguments, 1);\n\t    return function () {\n\t        var nodeArgs = baseArgs.concat(array_slice(arguments));\n\t        var deferred = defer();\n\t        nodeArgs.push(deferred.makeNodeResolver());\n\t        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n\t        return deferred.promise;\n\t    };\n\t};\n\t\n\tPromise.prototype.nfbind =\n\tPromise.prototype.denodeify = function (/*...args*/) {\n\t    var args = array_slice(arguments);\n\t    args.unshift(this);\n\t    return Q.denodeify.apply(void 0, args);\n\t};\n\t\n\tQ.nbind = function (callback, thisp /*...args*/) {\n\t    var baseArgs = array_slice(arguments, 2);\n\t    return function () {\n\t        var nodeArgs = baseArgs.concat(array_slice(arguments));\n\t        var deferred = defer();\n\t        nodeArgs.push(deferred.makeNodeResolver());\n\t        function bound() {\n\t            return callback.apply(thisp, arguments);\n\t        }\n\t        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n\t        return deferred.promise;\n\t    };\n\t};\n\t\n\tPromise.prototype.nbind = function (/*thisp, ...args*/) {\n\t    var args = array_slice(arguments, 0);\n\t    args.unshift(this);\n\t    return Q.nbind.apply(void 0, args);\n\t};\n\t\n\t/**\n\t * Calls a method of a Node-style object that accepts a Node-style\n\t * callback with a given array of arguments, plus a provided callback.\n\t * @param object an object that has the named method\n\t * @param {String} name name of the method of object\n\t * @param {Array} args arguments to pass to the method; the callback\n\t * will be provided by Q and appended to these arguments.\n\t * @returns a promise for the value or error\n\t */\n\tQ.nmapply = // XXX As proposed by \"Redsandro\"\n\tQ.npost = function (object, name, args) {\n\t    return Q(object).npost(name, args);\n\t};\n\t\n\tPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\n\tPromise.prototype.npost = function (name, args) {\n\t    var nodeArgs = array_slice(args || []);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Calls a method of a Node-style object that accepts a Node-style\n\t * callback, forwarding the given variadic arguments, plus a provided\n\t * callback argument.\n\t * @param object an object that has the named method\n\t * @param {String} name name of the method of object\n\t * @param ...args arguments to pass to the method; the callback will\n\t * be provided by Q and appended to these arguments.\n\t * @returns a promise for the value or error\n\t */\n\tQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\n\tQ.nmcall = // XXX Based on \"Redsandro's\" proposal\n\tQ.ninvoke = function (object, name /*...args*/) {\n\t    var nodeArgs = array_slice(arguments, 2);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\tPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\n\tPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\n\tPromise.prototype.ninvoke = function (name /*...args*/) {\n\t    var nodeArgs = array_slice(arguments, 1);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * If a function would like to support both Node continuation-passing-style and\n\t * promise-returning-style, it can end its internal promise chain with\n\t * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n\t * elects to use a nodeback, the result will be sent there.  If they do not\n\t * pass a nodeback, they will receive the result promise.\n\t * @param object a result (or a promise for a result)\n\t * @param {Function} nodeback a Node.js-style callback\n\t * @returns either the promise or nothing\n\t */\n\tQ.nodeify = nodeify;\n\tfunction nodeify(object, nodeback) {\n\t    return Q(object).nodeify(nodeback);\n\t}\n\t\n\tPromise.prototype.nodeify = function (nodeback) {\n\t    if (nodeback) {\n\t        this.then(function (value) {\n\t            Q.nextTick(function () {\n\t                nodeback(null, value);\n\t            });\n\t        }, function (error) {\n\t            Q.nextTick(function () {\n\t                nodeback(error);\n\t            });\n\t        });\n\t    } else {\n\t        return this;\n\t    }\n\t};\n\t\n\tQ.noConflict = function() {\n\t    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n\t};\n\t\n\t// All code before this point will be filtered from stack traces.\n\tvar qEndingLine = captureLine();\n\t\n\treturn Q;\n\t\n\t});\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(5).setImmediate))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n\t    \"use strict\";\n\t\n\t    if (global.setImmediate) {\n\t        return;\n\t    }\n\t\n\t    var nextHandle = 1; // Spec says greater than zero\n\t    var tasksByHandle = {};\n\t    var currentlyRunningATask = false;\n\t    var doc = global.document;\n\t    var registerImmediate;\n\t\n\t    function setImmediate(callback) {\n\t      // Callback can either be a function or a string\n\t      if (typeof callback !== \"function\") {\n\t        callback = new Function(\"\" + callback);\n\t      }\n\t      // Copy function arguments\n\t      var args = new Array(arguments.length - 1);\n\t      for (var i = 0; i < args.length; i++) {\n\t          args[i] = arguments[i + 1];\n\t      }\n\t      // Store and register the task\n\t      var task = { callback: callback, args: args };\n\t      tasksByHandle[nextHandle] = task;\n\t      registerImmediate(nextHandle);\n\t      return nextHandle++;\n\t    }\n\t\n\t    function clearImmediate(handle) {\n\t        delete tasksByHandle[handle];\n\t    }\n\t\n\t    function run(task) {\n\t        var callback = task.callback;\n\t        var args = task.args;\n\t        switch (args.length) {\n\t        case 0:\n\t            callback();\n\t            break;\n\t        case 1:\n\t            callback(args[0]);\n\t            break;\n\t        case 2:\n\t            callback(args[0], args[1]);\n\t            break;\n\t        case 3:\n\t            callback(args[0], args[1], args[2]);\n\t            break;\n\t        default:\n\t            callback.apply(undefined, args);\n\t            break;\n\t        }\n\t    }\n\t\n\t    function runIfPresent(handle) {\n\t        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n\t        // So if we're currently running a task, we'll need to delay this invocation.\n\t        if (currentlyRunningATask) {\n\t            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n\t            // \"too much recursion\" error.\n\t            setTimeout(runIfPresent, 0, handle);\n\t        } else {\n\t            var task = tasksByHandle[handle];\n\t            if (task) {\n\t                currentlyRunningATask = true;\n\t                try {\n\t                    run(task);\n\t                } finally {\n\t                    clearImmediate(handle);\n\t                    currentlyRunningATask = false;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function installNextTickImplementation() {\n\t        registerImmediate = function(handle) {\n\t            process.nextTick(function () { runIfPresent(handle); });\n\t        };\n\t    }\n\t\n\t    function canUsePostMessage() {\n\t        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n\t        // where `global.postMessage` means something completely different and can't be used for this purpose.\n\t        if (global.postMessage && !global.importScripts) {\n\t            var postMessageIsAsynchronous = true;\n\t            var oldOnMessage = global.onmessage;\n\t            global.onmessage = function() {\n\t                postMessageIsAsynchronous = false;\n\t            };\n\t            global.postMessage(\"\", \"*\");\n\t            global.onmessage = oldOnMessage;\n\t            return postMessageIsAsynchronous;\n\t        }\n\t    }\n\t\n\t    function installPostMessageImplementation() {\n\t        // Installs an event handler on `global` for the `message` event: see\n\t        // * https://developer.mozilla.org/en/DOM/window.postMessage\n\t        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\t\n\t        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\t        var onGlobalMessage = function(event) {\n\t            if (event.source === global &&\n\t                typeof event.data === \"string\" &&\n\t                event.data.indexOf(messagePrefix) === 0) {\n\t                runIfPresent(+event.data.slice(messagePrefix.length));\n\t            }\n\t        };\n\t\n\t        if (global.addEventListener) {\n\t            global.addEventListener(\"message\", onGlobalMessage, false);\n\t        } else {\n\t            global.attachEvent(\"onmessage\", onGlobalMessage);\n\t        }\n\t\n\t        registerImmediate = function(handle) {\n\t            global.postMessage(messagePrefix + handle, \"*\");\n\t        };\n\t    }\n\t\n\t    function installMessageChannelImplementation() {\n\t        var channel = new MessageChannel();\n\t        channel.port1.onmessage = function(event) {\n\t            var handle = event.data;\n\t            runIfPresent(handle);\n\t        };\n\t\n\t        registerImmediate = function(handle) {\n\t            channel.port2.postMessage(handle);\n\t        };\n\t    }\n\t\n\t    function installReadyStateChangeImplementation() {\n\t        var html = doc.documentElement;\n\t        registerImmediate = function(handle) {\n\t            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t            var script = doc.createElement(\"script\");\n\t            script.onreadystatechange = function () {\n\t                runIfPresent(handle);\n\t                script.onreadystatechange = null;\n\t                html.removeChild(script);\n\t                script = null;\n\t            };\n\t            html.appendChild(script);\n\t        };\n\t    }\n\t\n\t    function installSetTimeoutImplementation() {\n\t        registerImmediate = function(handle) {\n\t            setTimeout(runIfPresent, 0, handle);\n\t        };\n\t    }\n\t\n\t    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\t    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n\t    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\t\n\t    // Don't get fooled by e.g. browserify environments.\n\t    if ({}.toString.call(global.process) === \"[object process]\") {\n\t        // For Node.js before 0.9\n\t        installNextTickImplementation();\n\t\n\t    } else if (canUsePostMessage()) {\n\t        // For non-IE10 modern browsers\n\t        installPostMessageImplementation();\n\t\n\t    } else if (global.MessageChannel) {\n\t        // For web workers, where supported\n\t        installMessageChannelImplementation();\n\t\n\t    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n\t        // For IE 6–8\n\t        installReadyStateChangeImplementation();\n\t\n\t    } else {\n\t        // For older browsers\n\t        installSetTimeoutImplementation();\n\t    }\n\t\n\t    attachTo.setImmediate = setImmediate;\n\t    attachTo.clearImmediate = clearImmediate;\n\t}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(1)))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar apply = Function.prototype.apply;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) {\n\t  if (timeout) {\n\t    timeout.close();\n\t  }\n\t};\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// setimmediate attaches itself to the global object\n\t__webpack_require__(4);\n\texports.setImmediate = setImmediate;\n\texports.clearImmediate = clearImmediate;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_9__;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_10__;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_11__;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_12__;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_13__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// react-scroller.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5b85c0c814aadc9802ba","import ReactScroller from 'components/react-scroller';\nexport default ReactScroller;\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/node-libs-browser/~/process/browser.js\n// module id = 1\n// module chunks = 0","import React, {PureComponent, createElement} from 'react';\n\nimport NxBrowser from 'next-browser';\nimport NxDomEvent from 'next-dom-event';\nimport PropTypes from 'prop-types';\nimport Q from 'q';\nimport ReactEventEmitter from 'react-event-emitter';\nimport Scroller from 'next-scroller';\nimport classNames from 'classnames';\nimport noop from 'noop';\n\nconst userAgent = navigator.userAgent;\nconst helperElem = document.createElement(\"div\");\nconst vendorPrefix = NxBrowser.jsPrefix();\nconst perspectiveProperty = vendorPrefix + \"Perspective\";\nconst transformProperty = vendorPrefix + \"Transform\";\nconst supportTransformProperty = helperElem.style[transformProperty] !== undefined;\nconst supportPerspectiveProperty = helperElem.style[perspectiveProperty] !== undefined;\nconst retainElementRE = /input|textarea|select/i;\nconst INNER_STATUS = ['init', 'active', 'running'];\n\n//devices judgements:\nconst deviceIsWindowsPhone = userAgent.indexOf(\"Windows Phone\") >= 0;\nconst deviceIsAndroid = userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;\nconst deviceIsIOS = /iP(ad|hone|od)/.test(userAgent) && !deviceIsWindowsPhone;\n\n\nexport default class extends ReactEventEmitter {\n  static propTypes = {\n    className: PropTypes.string,\n    options: PropTypes.object,\n    refresherStatus: PropTypes.string,\n    infiniterStatus: PropTypes.string,\n    onRefresh: PropTypes.func,\n    refresher: PropTypes.func,\n    infiniter: PropTypes.func,\n    distance: PropTypes.array,\n    onInfinite: PropTypes.func,\n    onScroll: PropTypes.func,\n    onScrollEnd: PropTypes.func,\n  };\n\n  static defaultProps = {\n    options: {\n      animationDuration: 300,\n      scrollingX: false,\n      speedMultiplier:0.8,\n      penetrationDeceleration: 0.1,\n      penetrationAcceleration: 0.1\n    },\n    refresherStatus: 'init',\n    infiniterStatus: 'init',\n    onRefresh: noop,\n    onInfinite: noop,\n    onScroll: noop,\n    onScrollEnd: noop,\n    refresher: null,\n    infiniter: null,\n    distances: [50, 50]\n  };\n\n  constructor(props) {\n    super(props);\n    this.init();\n    this._mouted = false;\n  }\n\n  init() {\n    const {refresherStatus, infiniterStatus} = this.props;\n    this.attachDocEvents();\n    this.createScroller();\n    this.activatePullToRrefresh();\n    this.state = {\n      contentStyle: {},\n      refresherStatus,\n      infiniterStatus\n    };\n  }\n  componentAttachEvents(){}\n\n  componentWillUnmount() {\n    // this.detachDocEvents();\n    // this._scroller = null;\n    this._mouted = false;\n    // super.componentWillUnmount();\n  }\n\n  componentDidMount() {\n    this.refresh();\n    this._mouted = true;\n  }\n\n  componentWillReceiveProps(inNextProps) {\n    this.setState(inNextProps);\n  }\n\n  componentDidUpdate(nextProps) {\n    if (nextProps.children !== this.props.children) {\n      this.refresh();\n    }\n  }\n\n  attachDocEvents() {\n    this._loadRes = NxDomEvent.on(window,'load',this._onRefresh);\n    this._touchmoveRes = NxDomEvent.on(document,'touchmove',this._onMove );\n    this._touchendRes = NxDomEvent.on(document,'touchend', this._onEnd );\n  }\n\n  detachDocEvents() {\n    this._loadRes.destory();\n    this._touchmoveRes.destory();\n    this._touchendRes.destory();\n  }\n\n  createScroller() {\n    const {options} = this.props;\n    this._scroller = new Scroller(this.scrollerRender(), options);\n  }\n\n  refresh() {\n    let {container, content} = this.refs;\n    this._scroller.setDimensions(\n      container.clientWidth,\n      container.clientHeight,\n      content.offsetWidth,\n      content.offsetHeight\n    );\n  }\n\n  getValues (){\n    return this._scroller.getValues();\n  }\n\n  scrollTo( inLeft,inTop,inAnimate,inZoom ){\n    this._scroller.scrollTo( inLeft,inTop,inAnimate,inZoom );\n  }\n\n  scrollerRender() {\n    switch (true) {\n      case supportPerspectiveProperty:\n        return (left, top, inZoom) => {\n          const transformPropertyValue = 'translate3d(' + (-left) + 'px,' + (-top) + 'px,0) scale(' + inZoom + ')';\n          this._mouted && this.setState({contentStyle: {[transformProperty]: transformPropertyValue}});\n        };\n      case supportTransformProperty:\n        return (left, top, inZoom) => {\n          const transformPropertyValue = 'translate(' + (-left) + 'px,' + (-top) + 'px) scale(' + inZoom + ')';\n          this._mouted && this.setState({contentStyle: {[transformProperty]: transformPropertyValue}});\n        };\n      default:\n        return (left, top, inZoom) => {\n          const marginLeft = left ? (-left / inZoom) + 'px' : '';\n          const marginTop = top ? (-top / inZoom) + 'px' : '';\n          const zoom = inZoom || '';\n          this._mouted && this.setState({contentStyle: {marginLeft, marginTop, inZoom}});\n        };\n    }\n  }\n\n  activateInfinite() {\n    let {container, content} = this.refs;\n    const {distances, infiniter} = this.props;\n    const isInnerStatus = INNER_STATUS.indexOf(this.state.infiniterStatus) > -1;\n    if (infiniter && isInnerStatus && container && content) {\n      const contentBound = content.getBoundingClientRect();\n      const containerBound = container.getBoundingClientRect();\n      console.log(contentBound.bottom - containerBound.bottom);\n      if (contentBound.bottom - containerBound.bottom < distances[1]) {\n        this.setState({infiniterStatus: 'active'});\n      } else {\n        this.setState({infiniterStatus: 'init'});\n      }\n    }\n  }\n\n  activatePullToRrefresh() {\n    let {distances, refresher, onRefresh} = this.props;\n    if (refresher) {\n      this._scroller.activatePullToRefresh(distances[0], () => {\n        this.setState({refresherStatus: 'active'});\n      }, () => {\n        this.setState({\n          refresherStatus: 'init',\n          infiniterStatus: 'init',\n        });\n      }, () => {\n        this.setState({refresherStatus: 'running'});\n        this._scroller.__refreshActive && onRefresh.call(this, this);\n      });\n    }\n  }\n\n  finishInfinte() {\n    const isInnerStatus = INNER_STATUS.indexOf(this.state.infiniterStatus) > -1;\n    if(isInnerStatus){\n      this.setState({infiniterStatus: 'init'});\n    }\n  }\n\n  finishPullToRefresh() {\n    this._scroller && this._scroller.finishPullToRefresh();\n  }\n\n  shouldRetainDefault(inEvent) {\n    return inEvent.target.tagName.match(retainElementRE);\n  }\n\n  _onStart = (inEvent) => {\n    if (!this.shouldRetainDefault(inEvent) && deviceIsIOS) {\n      inEvent.preventDefault();\n    }\n    this._scroller.doTouchStart(inEvent.touches, inEvent.timeStamp);\n  };\n\n  _onRefresh = () => {\n    this.refresh();\n  };\n\n  _onMove = (inEvent) => {\n    const { onScroll } = this.props;\n    const scrollValues = this._scroller.getValues();\n    if (this.shouldRetainDefault(inEvent)) {\n      return null;\n    }\n    this._scroller.doTouchMove(inEvent.touches, inEvent.timeStamp);\n    this.activateInfinite();\n    onScroll( scrollValues );\n    this.fire('scroll', scrollValues );\n    inEvent.preventDefault();\n  };\n\n  _onEnd = (inEvent) => {\n    this.doEnd(inEvent);\n    this.delayCheck();\n    this._scroller.doTouchEnd(inEvent.timeStamp);\n  };\n\n  doEnd(inEvent){\n    let {infiniterStatus} = this.state;\n    let {onInfinite,onScrollEnd} = this.props;\n    if (infiniterStatus === 'active') {\n      this.setState({infiniterStatus: 'running'},()=>{\n        !this._scroller.__refreshActive && onInfinite.call(this, this);\n      });\n    }\n    onScrollEnd(inEvent);\n    this.fire('scrollEnd',inEvent);\n  }\n\n  delayCheck(inEvent){\n    const timer = setTimeout(()=>{\n      this.activateInfinite();\n      this.doEnd(inEvent);\n      clearTimeout(timer);\n    },500);\n  }\n\n  render() {\n    const { contentStyle } = this.state;\n    const {\n      className, children, refresher, infiniter,\n      onInfinite, onRefresh, options, distances,\n      refresherStatus, infiniterStatus,\n      onScroll,onScrollEnd,\n      ...props\n    } = this.props;\n\n    return (\n      <div\n        {...props}\n        ref='container'\n        className={classNames('react-scroller', className)}\n        onTouchStart={this._onStart}>\n        <div\n          ref='content'\n          className=\"react-scroller-content\" style={contentStyle}>\n          {refresher && createElement(refresher, {status: this.state.refresherStatus})}\n          <div className=\"bd\">\n            {children}\n          </div>\n          {infiniter && createElement(infiniter, {status: this.state.infiniterStatus})}\n        </div>\n      </div>\n    );\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/react-scroller.js","// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2017 Kris Kowal under the terms of the MIT\n * license found at https://github.com/kriskowal/q/blob/v1/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (definition) {\n    \"use strict\";\n\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n\n    // CommonJS\n    } else if (typeof exports === \"object\" && typeof module === \"object\") {\n        module.exports = definition();\n\n    // RequireJS\n    } else if (typeof define === \"function\" && define.amd) {\n        define(definition);\n\n    // SES (Secure EcmaScript)\n    } else if (typeof ses !== \"undefined\") {\n        if (!ses.ok()) {\n            return;\n        } else {\n            ses.makeQ = definition;\n        }\n\n    // <script>\n    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n        // Prefer window over self for add-on scripts. Use self for\n        // non-windowed contexts.\n        var global = typeof window !== \"undefined\" ? window : self;\n\n        // Get the `window` object, save the previous Q global\n        // and initialize Q as a global.\n        var previousQ = global.Q;\n        global.Q = definition();\n\n        // Add a noConflict function so Q can be removed from the\n        // global namespace.\n        global.Q.noConflict = function () {\n            global.Q = previousQ;\n            return this;\n        };\n\n    } else {\n        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n    }\n\n})(function () {\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\n// shims\n\n// used for fallback in \"allResolved\"\nvar noop = function () {};\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\nvar nextTick =(function () {\n    // linked list of tasks (single, with head node)\n    var head = {task: void 0, next: null};\n    var tail = head;\n    var flushing = false;\n    var requestTick = void 0;\n    var isNodeJS = false;\n    // queue for late tasks, used by unhandled rejection tracking\n    var laterQueue = [];\n\n    function flush() {\n        /* jshint loopfunc: true */\n        var task, domain;\n\n        while (head.next) {\n            head = head.next;\n            task = head.task;\n            head.task = void 0;\n            domain = head.domain;\n\n            if (domain) {\n                head.domain = void 0;\n                domain.enter();\n            }\n            runSingle(task, domain);\n\n        }\n        while (laterQueue.length) {\n            task = laterQueue.pop();\n            runSingle(task);\n        }\n        flushing = false;\n    }\n    // runs a single function in the async queue\n    function runSingle(task, domain) {\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function () {\n                    throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    nextTick = function (task) {\n        tail = tail.next = {\n            task: task,\n            domain: isNodeJS && process.domain,\n            next: null\n        };\n\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n\n    if (typeof process === \"object\" &&\n        process.toString() === \"[object process]\" && process.nextTick) {\n        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n        // To see through fake Node environments:\n        // * Mocha test runner - exposes a `process` global without a `nextTick`\n        // * Browserify - exposes a `process.nexTick` function that uses\n        //   `setTimeout`. In this case `setImmediate` is preferred because\n        //    it is faster. Browserify's `process.toString()` yields\n        //   \"[object Object]\", while in a real Node environment\n        //   `process.toString()` yields \"[object process]\".\n        isNodeJS = true;\n\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n\n    } else if (typeof setImmediate === \"function\") {\n        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n        if (typeof window !== \"undefined\") {\n            requestTick = setImmediate.bind(window, flush);\n        } else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n\n    } else if (typeof MessageChannel !== \"undefined\") {\n        // modern browsers\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n        var channel = new MessageChannel();\n        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n        // working message ports the first time a page loads.\n        channel.port1.onmessage = function () {\n            requestTick = requestPortTick;\n            channel.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick = function () {\n            // Opera requires us to provide a message payload, regardless of\n            // whether we use it.\n            channel.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick();\n        };\n\n    } else {\n        // old browsers\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n    // runs a task after all other tasks have been run\n    // this is useful for unhandled rejection tracking that needs to happen\n    // after all `then`d tasks have been run.\n    nextTick.runAfter = function (task) {\n        laterQueue.push(task);\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n    return nextTick;\n})();\n\n// Attempt to make generics safe in the face of downstream\n// modifications.\n// There is no situation where this is necessary.\n// If you need a security guarantee, these primordials need to be\n// deeply frozen anyway, and if you don’t need a security guarantee,\n// this is just plain paranoid.\n// However, this **might** have the nice side-effect of reducing the size of\n// the minified code by reducing x.call() to merely x()\n// See Mark Miller’s explanation of what this does.\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\nvar call = Function.call;\nfunction uncurryThis(f) {\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n// http://jsperf.com/uncurrythis\n\nvar array_slice = uncurryThis(Array.prototype.slice);\n\nvar array_reduce = uncurryThis(\n    Array.prototype.reduce || function (callback, basis) {\n        var index = 0,\n            length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            } while (1);\n        }\n        // reduce\n        for (; index < length; index++) {\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    }\n);\n\nvar array_indexOf = uncurryThis(\n    Array.prototype.indexOf || function (value) {\n        // not a very good shim, but good enough for our one use of it\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n);\n\nvar array_map = uncurryThis(\n    Array.prototype.map || function (callback, thisp) {\n        var self = this;\n        var collect = [];\n        array_reduce(self, function (undefined, value, index) {\n            collect.push(callback.call(thisp, value, index, self));\n        }, void 0);\n        return collect;\n    }\n);\n\nvar object_create = Object.create || function (prototype) {\n    function Type() { }\n    Type.prototype = prototype;\n    return new Type();\n};\n\nvar object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {\n    obj[prop] = descriptor.value;\n    return obj;\n};\n\nvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\nvar object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n        if (object_hasOwnProperty(object, key)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n};\n\nvar object_toString = uncurryThis(Object.prototype.toString);\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// generator related shims\n\n// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\n\n// FIXME: Remove this helper and Q.return once ES6 generators are in\n// SpiderMonkey.\nvar QReturnValue;\nif (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n} else {\n    QReturnValue = function (value) {\n        this.value = value;\n    };\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p; p = p.source) {\n            if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {\n                object_defineProperty(error, \"__minimumStackCounter__\", {value: p.stackCounter, configurable: true});\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        var stack = filterStackString(concatedStacks);\n        object_defineProperty(error, \"stack\", {value: stack, configurable: true});\n    }\n}\n\nfunction filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function () {\n        if (typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\") {\n            console.warn(name + \" is deprecated, use \" + alternative +\n                         \" instead.\", new Error(\"\").stack);\n        }\n        return callback.apply(callback, arguments);\n    };\n}\n\n// end of shims\n// beginning of real work\n\n/**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (value instanceof Promise) {\n        return value;\n    }\n\n    // assimilate thenables\n    if (isPromiseAlike(value)) {\n        return coerce(value);\n    } else {\n        return fulfill(value);\n    }\n}\nQ.resolve = Q;\n\n/**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */\nQ.nextTick = nextTick;\n\n/**\n * Controls whether or not long stack traces will be on\n */\nQ.longStackSupport = false;\n\n/**\n * The counter is used to determine the stopping point for building\n * long stack traces. In makeStackTraceLong we walk backwards through\n * the linked list of promises, only stacks which were created before\n * the rejection are concatenated.\n */\nvar longStackCounter = 1;\n\n// enable long stacks if Q_DEBUG is set\nif (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n    Q.longStackSupport = true;\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */\nQ.defer = defer;\nfunction defer() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    var messages = [], progressListeners = [], resolvedPromise;\n\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, operands) {\n        var args = array_slice(arguments);\n        if (messages) {\n            messages.push(args);\n            if (op === \"when\" && operands[1]) { // progress operand\n                progressListeners.push(operands[1]);\n            }\n        } else {\n            Q.nextTick(function () {\n                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n            });\n        }\n    };\n\n    // XXX deprecated\n    promise.valueOf = function () {\n        if (messages) {\n            return promise;\n        }\n        var nearerValue = nearer(resolvedPromise);\n        if (isPromise(nearerValue)) {\n            resolvedPromise = nearerValue; // shorten chain\n        }\n        return nearerValue;\n    };\n\n    promise.inspect = function () {\n        if (!resolvedPromise) {\n            return { state: \"pending\" };\n        }\n        return resolvedPromise.inspect();\n    };\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n            promise.stackCounter = longStackCounter++;\n        }\n    }\n\n    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n    // consolidating them into `become`, since otherwise we'd create new\n    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\n    function become(newPromise) {\n        resolvedPromise = newPromise;\n\n        if (Q.longStackSupport && hasStacks) {\n            // Only hold a reference to the new promise if long stacks\n            // are enabled to reduce memory usage\n            promise.source = newPromise;\n        }\n\n        array_reduce(messages, function (undefined, message) {\n            Q.nextTick(function () {\n                newPromise.promiseDispatch.apply(newPromise, message);\n            });\n        }, void 0);\n\n        messages = void 0;\n        progressListeners = void 0;\n    }\n\n    deferred.promise = promise;\n    deferred.resolve = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(Q(value));\n    };\n\n    deferred.fulfill = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(fulfill(value));\n    };\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n    deferred.notify = function (progress) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        array_reduce(progressListeners, function (undefined, progressListener) {\n            Q.nextTick(function () {\n                progressListener(progress);\n            });\n        }, void 0);\n    };\n\n    return deferred;\n}\n\n/**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */\ndefer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n        if (error) {\n            self.reject(error);\n        } else if (arguments.length > 2) {\n            self.resolve(array_slice(arguments, 1));\n        } else {\n            self.resolve(value);\n        }\n    };\n};\n\n/**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */\nQ.Promise = promise; // ES6\nQ.promise = promise;\nfunction promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"resolver must be a function.\");\n    }\n    var deferred = defer();\n    try {\n        resolver(deferred.resolve, deferred.reject, deferred.notify);\n    } catch (reason) {\n        deferred.reject(reason);\n    }\n    return deferred.promise;\n}\n\npromise.race = race; // ES6\npromise.all = all; // ES6\npromise.reject = reject; // ES6\npromise.resolve = Q; // ES6\n\n// XXX experimental.  This method is a way to denote that a local value is\n// serializable and should be immediately dispatched to a remote upon request,\n// instead of passing a reference.\nQ.passByCopy = function (object) {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return object;\n};\n\nPromise.prototype.passByCopy = function () {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return this;\n};\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function (x, y) {\n    return Q(x).join(y);\n};\n\nPromise.prototype.join = function (that) {\n    return Q([this, that]).spread(function (x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Q can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */\nQ.race = race;\nfunction race(answerPs) {\n    return promise(function (resolve, reject) {\n        // Switch to this once we can assume at least ES5\n        // answerPs.forEach(function (answerP) {\n        //     Q(answerP).then(resolve, reject);\n        // });\n        // Use this in the meantime\n        for (var i = 0, len = answerPs.length; i < len; i++) {\n            Q(answerPs[i]).then(resolve, reject);\n        }\n    });\n}\n\nPromise.prototype.race = function () {\n    return this.then(Q.race);\n};\n\n/**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */\nQ.makePromise = Promise;\nfunction Promise(descriptor, fallback, inspect) {\n    if (fallback === void 0) {\n        fallback = function (op) {\n            return reject(new Error(\n                \"Promise does not support operation: \" + op\n            ));\n        };\n    }\n    if (inspect === void 0) {\n        inspect = function () {\n            return {state: \"unknown\"};\n        };\n    }\n\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, args) {\n        var result;\n        try {\n            if (descriptor[op]) {\n                result = descriptor[op].apply(promise, args);\n            } else {\n                result = fallback.call(promise, op, args);\n            }\n        } catch (exception) {\n            result = reject(exception);\n        }\n        if (resolve) {\n            resolve(result);\n        }\n    };\n\n    promise.inspect = inspect;\n\n    // XXX deprecated `valueOf` and `exception` support\n    if (inspect) {\n        var inspected = inspect();\n        if (inspected.state === \"rejected\") {\n            promise.exception = inspected.reason;\n        }\n\n        promise.valueOf = function () {\n            var inspected = inspect();\n            if (inspected.state === \"pending\" ||\n                inspected.state === \"rejected\") {\n                return promise;\n            }\n            return inspected.value;\n        };\n    }\n\n    return promise;\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.then = function (fulfilled, rejected, progressed) {\n    var self = this;\n    var deferred = defer();\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n\n    function _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            return reject(exception);\n        }\n    }\n\n    function _rejected(exception) {\n        if (typeof rejected === \"function\") {\n            makeStackTraceLong(exception, self);\n            try {\n                return rejected(exception);\n            } catch (newException) {\n                return reject(newException);\n            }\n        }\n        return reject(exception);\n    }\n\n    function _progressed(value) {\n        return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n\n    Q.nextTick(function () {\n        self.promiseDispatch(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }, \"when\", [function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_rejected(exception));\n        }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n        var newValue;\n        var threw = false;\n        try {\n            newValue = _progressed(value);\n        } catch (e) {\n            threw = true;\n            if (Q.onerror) {\n                Q.onerror(e);\n            } else {\n                throw e;\n            }\n        }\n\n        if (!threw) {\n            deferred.notify(newValue);\n        }\n    }]);\n\n    return deferred.promise;\n};\n\nQ.tap = function (promise, callback) {\n    return Q(promise).tap(callback);\n};\n\n/**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */\nPromise.prototype.tap = function (callback) {\n    callback = Q(callback);\n\n    return this.then(function (value) {\n        return callback.fcall(value).thenResolve(value);\n    });\n};\n\n/**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */\nQ.when = when;\nfunction when(value, fulfilled, rejected, progressed) {\n    return Q(value).then(fulfilled, rejected, progressed);\n}\n\nPromise.prototype.thenResolve = function (value) {\n    return this.then(function () { return value; });\n};\n\nQ.thenResolve = function (promise, value) {\n    return Q(promise).thenResolve(value);\n};\n\nPromise.prototype.thenReject = function (reason) {\n    return this.then(function () { throw reason; });\n};\n\nQ.thenReject = function (promise, reason) {\n    return Q(promise).thenReject(reason);\n};\n\n/**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If it’s a fulfilled promise, the fulfillment value is nearer.\n * If it’s a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */\n\n// XXX should we re-do this?\nQ.nearer = nearer;\nfunction nearer(value) {\n    if (isPromise(value)) {\n        var inspected = value.inspect();\n        if (inspected.state === \"fulfilled\") {\n            return inspected.value;\n        }\n    }\n    return value;\n}\n\n/**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */\nQ.isPromise = isPromise;\nfunction isPromise(object) {\n    return object instanceof Promise;\n}\n\nQ.isPromiseAlike = isPromiseAlike;\nfunction isPromiseAlike(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */\nQ.isPending = isPending;\nfunction isPending(object) {\n    return isPromise(object) && object.inspect().state === \"pending\";\n}\n\nPromise.prototype.isPending = function () {\n    return this.inspect().state === \"pending\";\n};\n\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n}\n\nPromise.prototype.isFulfilled = function () {\n    return this.inspect().state === \"fulfilled\";\n};\n\n/**\n * @returns whether the given object is a rejected promise.\n */\nQ.isRejected = isRejected;\nfunction isRejected(object) {\n    return isPromise(object) && object.inspect().state === \"rejected\";\n}\n\nPromise.prototype.isRejected = function () {\n    return this.inspect().state === \"rejected\";\n};\n\n//// BEGIN UNHANDLED REJECTION TRACKING\n\n// This promise library consumes exceptions thrown in handlers so they can be\n// handled by a subsequent promise.  The exceptions get added to this array when\n// they are created, and removed when they are handled.  Note that in ES6 or\n// shimmed environments, this would naturally be a `Set`.\nvar unhandledReasons = [];\nvar unhandledRejections = [];\nvar reportedUnhandledRejections = [];\nvar trackUnhandledRejections = true;\n\nfunction resetUnhandledRejections() {\n    unhandledReasons.length = 0;\n    unhandledRejections.length = 0;\n\n    if (!trackUnhandledRejections) {\n        trackUnhandledRejections = true;\n    }\n}\n\nfunction trackRejection(promise, reason) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n        Q.nextTick.runAfter(function () {\n            if (array_indexOf(unhandledRejections, promise) !== -1) {\n                process.emit(\"unhandledRejection\", reason, promise);\n                reportedUnhandledRejections.push(promise);\n            }\n        });\n    }\n\n    unhandledRejections.push(promise);\n    if (reason && typeof reason.stack !== \"undefined\") {\n        unhandledReasons.push(reason.stack);\n    } else {\n        unhandledReasons.push(\"(no stack) \" + reason);\n    }\n}\n\nfunction untrackRejection(promise) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    var at = array_indexOf(unhandledRejections, promise);\n    if (at !== -1) {\n        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n            Q.nextTick.runAfter(function () {\n                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n                if (atReport !== -1) {\n                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n                    reportedUnhandledRejections.splice(atReport, 1);\n                }\n            });\n        }\n        unhandledRejections.splice(at, 1);\n        unhandledReasons.splice(at, 1);\n    }\n}\n\nQ.resetUnhandledRejections = resetUnhandledRejections;\n\nQ.getUnhandledReasons = function () {\n    // Make a copy so that consumers can't interfere with our internal state.\n    return unhandledReasons.slice();\n};\n\nQ.stopUnhandledRejectionTracking = function () {\n    resetUnhandledRejections();\n    trackUnhandledRejections = false;\n};\n\nresetUnhandledRejections();\n\n//// END UNHANDLED REJECTION TRACKING\n\n/**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */\nQ.reject = reject;\nfunction reject(reason) {\n    var rejection = Promise({\n        \"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                untrackRejection(this);\n            }\n            return rejected ? rejected(reason) : this;\n        }\n    }, function fallback() {\n        return this;\n    }, function inspect() {\n        return { state: \"rejected\", reason: reason };\n    });\n\n    // Note that the reason has not been handled.\n    trackRejection(rejection, reason);\n\n    return rejection;\n}\n\n/**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */\nQ.fulfill = fulfill;\nfunction fulfill(value) {\n    return Promise({\n        \"when\": function () {\n            return value;\n        },\n        \"get\": function (name) {\n            return value[name];\n        },\n        \"set\": function (name, rhs) {\n            value[name] = rhs;\n        },\n        \"delete\": function (name) {\n            delete value[name];\n        },\n        \"post\": function (name, args) {\n            // Mark Miller proposes that post with no name should apply a\n            // promised function.\n            if (name === null || name === void 0) {\n                return value.apply(void 0, args);\n            } else {\n                return value[name].apply(value, args);\n            }\n        },\n        \"apply\": function (thisp, args) {\n            return value.apply(thisp, args);\n        },\n        \"keys\": function () {\n            return object_keys(value);\n        }\n    }, void 0, function inspect() {\n        return { state: \"fulfilled\", value: value };\n    });\n}\n\n/**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */\nfunction coerce(promise) {\n    var deferred = defer();\n    Q.nextTick(function () {\n        try {\n            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (exception) {\n            deferred.reject(exception);\n        }\n    });\n    return deferred.promise;\n}\n\n/**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */\nQ.master = master;\nfunction master(object) {\n    return Promise({\n        \"isDef\": function () {}\n    }, function fallback(op, args) {\n        return dispatch(object, op, args);\n    }, function () {\n        return Q(object).inspect();\n    });\n}\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = spread;\nfunction spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\nPromise.prototype.spread = function (fulfilled, rejected) {\n    return this.all().then(function (array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected);\n};\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = async;\nfunction async(makeGenerator) {\n    return function () {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var result;\n\n            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n            // engine that has a deployed base of browsers that support generators.\n            // However, SM's generators use the Python-inspired semantics of\n            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n            // like to make it possible to use generators in deployed browsers, so\n            // we also support Python-style generators.  At some point we can remove\n            // this block.\n\n            if (typeof StopIteration === \"undefined\") {\n                // ES6 Generators\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    return reject(exception);\n                }\n                if (result.done) {\n                    return Q(result.value);\n                } else {\n                    return when(result.value, callback, errback);\n                }\n            } else {\n                // SpiderMonkey Generators\n                // FIXME: Remove this case when SM does ES6 generators.\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    if (isStopIteration(exception)) {\n                        return Q(exception.value);\n                    } else {\n                        return reject(exception);\n                    }\n                }\n                return when(result, callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = spawn;\nfunction spawn(makeGenerator) {\n    Q.done(Q.async(makeGenerator)());\n}\n\n// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n/**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */\nQ[\"return\"] = _return;\nfunction _return(value) {\n    throw new QReturnValue(value);\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = promised;\nfunction promised(callback) {\n    return function () {\n        return spread([this, all(arguments)], function (self, args) {\n            return callback.apply(self, args);\n        });\n    };\n}\n\n/**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */\nQ.dispatch = dispatch;\nfunction dispatch(object, op, args) {\n    return Q(object).dispatch(op, args);\n}\n\nPromise.prototype.dispatch = function (op, args) {\n    var self = this;\n    var deferred = defer();\n    Q.nextTick(function () {\n        self.promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n};\n\n/**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */\nQ.get = function (object, key) {\n    return Q(object).dispatch(\"get\", [key]);\n};\n\nPromise.prototype.get = function (key) {\n    return this.dispatch(\"get\", [key]);\n};\n\n/**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */\nQ.set = function (object, key, value) {\n    return Q(object).dispatch(\"set\", [key, value]);\n};\n\nPromise.prototype.set = function (key, value) {\n    return this.dispatch(\"set\", [key, value]);\n};\n\n/**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */\nQ.del = // XXX legacy\nQ[\"delete\"] = function (object, key) {\n    return Q(object).dispatch(\"delete\", [key]);\n};\n\nPromise.prototype.del = // XXX legacy\nPromise.prototype[\"delete\"] = function (key) {\n    return this.dispatch(\"delete\", [key]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */\n// bound locally because it is used by other methods\nQ.mapply = // XXX As proposed by \"Redsandro\"\nQ.post = function (object, name, args) {\n    return Q(object).dispatch(\"post\", [name, args]);\n};\n\nPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.post = function (name, args) {\n    return this.dispatch(\"post\", [name, args]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */\nQ.send = // XXX Mark Miller's proposed parlance\nQ.mcall = // XXX As proposed by \"Redsandro\"\nQ.invoke = function (object, name /*...args*/) {\n    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n};\n\nPromise.prototype.send = // XXX Mark Miller's proposed parlance\nPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\nPromise.prototype.invoke = function (name /*...args*/) {\n    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n};\n\n/**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */\nQ.fapply = function (object, args) {\n    return Q(object).dispatch(\"apply\", [void 0, args]);\n};\n\nPromise.prototype.fapply = function (args) {\n    return this.dispatch(\"apply\", [void 0, args]);\n};\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ[\"try\"] =\nQ.fcall = function (object /* ...args*/) {\n    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n};\n\nPromise.prototype.fcall = function (/*...args*/) {\n    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n};\n\n/**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.fbind = function (object /*...args*/) {\n    var promise = Q(object);\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\nPromise.prototype.fbind = function (/*...args*/) {\n    var promise = this;\n    var args = array_slice(arguments);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\n\n/**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */\nQ.keys = function (object) {\n    return Q(object).dispatch(\"keys\", []);\n};\n\nPromise.prototype.keys = function () {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = all;\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var pendingCount = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            var snapshot;\n            if (\n                isPromise(promise) &&\n                (snapshot = promise.inspect()).state === \"fulfilled\"\n            ) {\n                promises[index] = snapshot.value;\n            } else {\n                ++pendingCount;\n                when(\n                    promise,\n                    function (value) {\n                        promises[index] = value;\n                        if (--pendingCount === 0) {\n                            deferred.resolve(promises);\n                        }\n                    },\n                    deferred.reject,\n                    function (progress) {\n                        deferred.notify({ index: index, value: progress });\n                    }\n                );\n            }\n        }, void 0);\n        if (pendingCount === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n\nPromise.prototype.all = function () {\n    return all(this);\n};\n\n/**\n * Returns the first resolved promise of an array. Prior rejected promises are\n * ignored.  Rejects only if all promises are rejected.\n * @param {Array*} an array containing values or promises for values\n * @returns a promise fulfilled with the value of the first resolved promise,\n * or a rejected promise if all promises are rejected.\n */\nQ.any = any;\n\nfunction any(promises) {\n    if (promises.length === 0) {\n        return Q.resolve();\n    }\n\n    var deferred = Q.defer();\n    var pendingCount = 0;\n    array_reduce(promises, function (prev, current, index) {\n        var promise = promises[index];\n\n        pendingCount++;\n\n        when(promise, onFulfilled, onRejected, onProgress);\n        function onFulfilled(result) {\n            deferred.resolve(result);\n        }\n        function onRejected(err) {\n            pendingCount--;\n            if (pendingCount === 0) {\n                err.message = (\"Q can't get fulfillment value from any promise, all \" +\n                    \"promises were rejected. Last error message: \" + err.message);\n                deferred.reject(err);\n            }\n        }\n        function onProgress(progress) {\n            deferred.notify({\n                index: index,\n                value: progress\n            });\n        }\n    }, undefined);\n\n    return deferred.promise;\n}\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n/**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */\nQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\nfunction allResolved(promises) {\n    return when(promises, function (promises) {\n        promises = array_map(promises, Q);\n        return when(all(array_map(promises, function (promise) {\n            return when(promise, noop, noop);\n        })), function () {\n            return promises;\n        });\n    });\n}\n\nPromise.prototype.allResolved = function () {\n    return allResolved(this);\n};\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = allSettled;\nfunction allSettled(promises) {\n    return Q(promises).allSettled();\n}\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function () {\n    return this.then(function (promises) {\n        return all(array_map(promises, function (promise) {\n            promise = Q(promise);\n            function regardless() {\n                return promise.inspect();\n            }\n            return promise.then(regardless, regardless);\n        }));\n    });\n};\n\n/**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */\nQ.fail = // XXX legacy\nQ[\"catch\"] = function (object, rejected) {\n    return Q(object).then(void 0, rejected);\n};\n\nPromise.prototype.fail = // XXX legacy\nPromise.prototype[\"catch\"] = function (rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */\nQ.progress = progress;\nfunction progress(object, progressed) {\n    return Q(object).then(void 0, void 0, progressed);\n}\n\nPromise.prototype.progress = function (progressed) {\n    return this.then(void 0, void 0, progressed);\n};\n\n/**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */\nQ.fin = // XXX legacy\nQ[\"finally\"] = function (object, callback) {\n    return Q(object)[\"finally\"](callback);\n};\n\nPromise.prototype.fin = // XXX legacy\nPromise.prototype[\"finally\"] = function (callback) {\n    if (!callback || typeof callback.apply !== \"function\") {\n        throw new Error(\"Q can't apply finally callback\");\n    }\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.fcall().then(function () {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.fcall().then(function () {\n            throw reason;\n        });\n    });\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */\nQ.done = function (object, fulfilled, rejected, progress) {\n    return Q(object).done(fulfilled, rejected, progress);\n};\n\nPromise.prototype.done = function (fulfilled, rejected, progress) {\n    var onUnhandledError = function (error) {\n        // forward to a future turn so that ``when``\n        // does not catch it and turn it into a rejection.\n        Q.nextTick(function () {\n            makeStackTraceLong(error, promise);\n            if (Q.onerror) {\n                Q.onerror(error);\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promise = fulfilled || rejected || progress ?\n        this.then(fulfilled, rejected, progress) :\n        this;\n\n    if (typeof process === \"object\" && process && process.domain) {\n        onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n\n    promise.then(void 0, onUnhandledError);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function (object, ms, error) {\n    return Q(object).timeout(ms, error);\n};\n\nPromise.prototype.timeout = function (ms, error) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n        if (!error || \"string\" === typeof error) {\n            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n            error.code = \"ETIMEDOUT\";\n        }\n        deferred.reject(error);\n    }, ms);\n\n    this.then(function (value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function (exception) {\n        clearTimeout(timeoutId);\n        deferred.reject(exception);\n    }, deferred.notify);\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function (object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\nPromise.prototype.delay = function (timeout) {\n    return this.then(function (value) {\n        var deferred = defer();\n        setTimeout(function () {\n            deferred.resolve(value);\n        }, timeout);\n        return deferred.promise;\n    });\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfapply = function (callback, args) {\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfapply = function (args) {\n    var deferred = defer();\n    var nodeArgs = array_slice(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */\nQ.nfcall = function (callback /*...args*/) {\n    var args = array_slice(arguments, 1);\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfcall = function (/*...args*/) {\n    var nodeArgs = array_slice(arguments);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.nfbind =\nQ.denodeify = function (callback /*...args*/) {\n    if (callback === undefined) {\n        throw new Error(\"Q can't wrap an undefined function\");\n    }\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nfbind =\nPromise.prototype.denodeify = function (/*...args*/) {\n    var args = array_slice(arguments);\n    args.unshift(this);\n    return Q.denodeify.apply(void 0, args);\n};\n\nQ.nbind = function (callback, thisp /*...args*/) {\n    var baseArgs = array_slice(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nbind = function (/*thisp, ...args*/) {\n    var args = array_slice(arguments, 0);\n    args.unshift(this);\n    return Q.nbind.apply(void 0, args);\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nmapply = // XXX As proposed by \"Redsandro\"\nQ.npost = function (object, name, args) {\n    return Q(object).npost(name, args);\n};\n\nPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.npost = function (name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\nQ.nmcall = // XXX Based on \"Redsandro's\" proposal\nQ.ninvoke = function (object, name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\nPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\nPromise.prototype.ninvoke = function (name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */\nQ.nodeify = nodeify;\nfunction nodeify(object, nodeback) {\n    return Q(object).nodeify(nodeback);\n}\n\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        this.then(function (value) {\n            Q.nextTick(function () {\n                nodeback(null, value);\n            });\n        }, function (error) {\n            Q.nextTick(function () {\n                nodeback(error);\n            });\n        });\n    } else {\n        return this;\n    }\n};\n\nQ.noConflict = function() {\n    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n};\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\nreturn Q;\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/q/q.js\n// module id = 3\n// module chunks = 0","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/setimmediate/setImmediate.js\n// module id = 4\n// module chunks = 0","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/timers-browserify/main.js\n// module id = 5\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"classnames\"\n// module id = 6\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"next-browser\"\n// module id = 7\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"next-dom-event\"\n// module id = 8\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_9__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"next-scroller\"\n// module id = 9\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_10__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"noop\"\n// module id = 10\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_11__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"prop-types\"\n// module id = 11\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_12__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react\"\n// module id = 12\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_13__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react-event-emitter\"\n// module id = 13\n// module chunks = 0"],"sourceRoot":""}